
/*********************************************************************
*  Filepath: /base/static/tests/test_ir_model_fields_translation.js  *
*  Lines: 50                                                         *
*********************************************************************/
odoo.define('@base/../tests/test_ir_model_fields_translation', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");
function checkLoginColumn(translation) {
    return [
        stepUtils.showAppsMenuItem(), {
            content: "Settings",
            trigger: 'a[data-menu-xmlid="base.menu_administration"]',
            run: 'click',
        }, {
            content: "Open Users & Companies",
            trigger: '[data-menu-xmlid="base.menu_users"]',
            run: "click",
        }, {
            content: "Open Users",
            trigger: '[data-menu-xmlid="base.menu_action_res_users"]',
            run: "click",
        }, {
            content: `Login column should be ${translation}`,
            trigger: `[data-name="login"] span:contains("${translation}")`,
        }
    ]
}

registry.category("web_tour.tours").add('ir_model_fields_translation_en_tour', {
    url: '/odoo',
    steps: () => checkLoginColumn('Login')
});

registry.category("web_tour.tours").add('ir_model_fields_translation_en_tour2', {
    url: '/odoo',
    steps: () => checkLoginColumn('Login2')
});

registry.category("web_tour.tours").add('ir_model_fields_translation_fr_tour', {
    url: '/odoo',
    steps: () => checkLoginColumn('Identifiant')
});

registry.category("web_tour.tours").add('ir_model_fields_translation_fr_tour2', {
    url: '/odoo',
    steps: () => checkLoginColumn('Identifiant2')
});

return __exports;
});
;

/**********************************************************
*  Filepath: /web/static/tests/legacy/helpers/cleanup.js  *
*  Lines: 124                                             *
**********************************************************/
odoo.define('@web/../tests/legacy/helpers/cleanup', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=@web/../tests/helpers/cleanup default=false */

// -----------------------------------------------------------------------------
// Cleanup
// -----------------------------------------------------------------------------

const cleanups = [];

/**
 * Register a cleanup callback that will be executed whenever the current test
 * is done.
 *
 * - the cleanups will be executed in reverse order
 * - they will be executed even if the test fails/crashes
 *
 * @param {Function} callback
 */
__exports.registerCleanup = registerCleanup; function registerCleanup(callback) {
    cleanups.push(callback);
}

if (window.QUnit) {
    QUnit.on("OdooAfterTestHook", (info) => {
        if (QUnit.config.debug) {
            return;
        }
        let cleanup;
        // note that this calls the cleanup callbacks in reverse order!
        while ((cleanup = cleanups.pop())) {
            try {
                cleanup(info);
            } catch (error) {
                console.error(error);
            }
        }
    });

    // -----------------------------------------------------------------------------
    // Check leftovers
    // -----------------------------------------------------------------------------

    /**
     * List of elements tolerated in the body after a test. The property "keep"
     * prevents the element from being removed (typically: qunit suite elements).
     */
    const validElements = [
        // always in the body:
        { tagName: "DIV", attr: "id", value: "qunit", keep: true },
        { tagName: "DIV", attr: "id", value: "qunit-fixture", keep: true },
        // shouldn't be in the body after a test but are tolerated:
        { tagName: "SCRIPT", attr: "id", value: "" },
        { tagName: "DIV", attr: "class", value: "o_notification_manager" },
        { tagName: "DIV", attr: "class", value: "tooltip fade bs-tooltip-auto" },
        { tagName: "DIV", attr: "class", value: "tooltip fade bs-tooltip-auto show" },
        { tagName: "DIV", attr: "class", value: "tooltip tooltip-field-info fade bs-tooltip-auto" },
        {
            tagName: "DIV",
            attr: "class",
            value: "tooltip tooltip-field-info fade bs-tooltip-auto show",
        },

        // Due to a Document Kanban bug (already present in 12.0)
        { tagName: "DIV", attr: "class", value: "ui-helper-hidden-accessible" },
        {
            tagName: "UL",
            attr: "class",
            value: "ui-menu ui-widget ui-widget-content ui-autocomplete ui-front",
        },
        {
            tagName: "UL",
            attr: "class",
            value: "ui-menu ui-widget ui-widget-content ui-autocomplete dropdown-menu ui-front", // many2ones
        },
    ];

    /**
     * After each test, we check that there is no leftover in the DOM.
     *
     * Note: this event is not QUnit standard, we added it for this specific use case.
     * As a payload, an object with keys 'moduleName' and 'testName' is provided. It
     * is used to indicate the test that left elements in the DOM, when it happens.
     */
    QUnit.on("OdooAfterTestHook", function (info) {
        if (QUnit.config.debug) {
            return;
        }
        const failed = info.testReport.getStatus() === "failed";
        const toRemove = [];
        // check for leftover elements in the body
        for (const bodyChild of document.body.children) {
            const tolerated = validElements.find(
                (e) => e.tagName === bodyChild.tagName && bodyChild.getAttribute(e.attr) === e.value
            );
            if (!failed && !tolerated) {
                QUnit.pushFailure(
                    `Body still contains undesirable elements:\n${bodyChild.outerHTML}`
                );
            }
            if (!tolerated || !tolerated.keep) {
                toRemove.push(bodyChild);
            }
        }
        // cleanup leftovers in #qunit-fixture
        const qunitFixture = document.getElementById("qunit-fixture");
        if (qunitFixture.children.length) {
            toRemove.push(...qunitFixture.children);
        }
        // remove unwanted elements if not in debug
        for (const el of toRemove) {
            el.remove();
        }
        document.body.classList.remove("modal-open");
    });
}

return __exports;
});

odoo.define(`@web/../tests/helpers/cleanup`, ['@web/../tests/legacy/helpers/cleanup'], function (require) {
                        return require('@web/../tests/legacy/helpers/cleanup');
                        });
;

/********************************************************
*  Filepath: /web/static/tests/legacy/helpers/utils.js  *
*  Lines: 1144                                          *
********************************************************/
odoo.define('@web/../tests/legacy/helpers/utils', ['@web/core/templates', '@web/core/browser/browser', '@web/core/browser/feature_detection', '@web/core/network/download', '@web/core/popover/popover', '@web/core/utils/concurrency', '@web/core/utils/patch', '@web/core/utils/ui', '@web/core/l10n/translation', '@web/../tests/legacy/helpers/cleanup', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=@web/../tests/helpers/utils default=false */

const { getTemplate } = require("@web/core/templates");
const { browser } = require("@web/core/browser/browser");
const { isMacOS } = require("@web/core/browser/feature_detection");
const { download } = require("@web/core/network/download");
const { getPopoverForTarget } = require("@web/core/popover/popover");
const { Deferred } = require("@web/core/utils/concurrency");
const { patch } = require("@web/core/utils/patch");
const { isVisible } = require("@web/core/utils/ui");
const { _t } = require("@web/core/l10n/translation");
const { registerCleanup } = require("@web/../tests/legacy/helpers/cleanup");

const {
    App,
    onError,
    onMounted,
    onPatched,
    onRendered,
    onWillDestroy,
    onWillPatch,
    onWillRender,
    onWillStart,
    onWillUnmount,
    onWillUpdateProps,
    useComponent,
} = require("@odoo/owl");

/**
 * @typedef {keyof HTMLElementEventMap | keyof WindowEventMap} EventType
 *
 * @typedef {Side | `${Side}-${Side}` | { x?: number, y?: number }} Position
 *
 * @typedef {"bottom" | "left" | "right" | "top"} Side
 *
 * @typedef TriggerEventOptions
 * @property {boolean} [skipVisibilityCheck=false]
 * @property {boolean} [sync=false]
 */

/**
 * Patch the native Date object
 *
 * Note that it will be automatically unpatched at the end of the test
 *
 * @param {number} [year]
 * @param {number} [month]
 * @param {number} [day]
 * @param {number} [hours]
 * @param {number} [minutes]
 * @param {number} [seconds]
 * @param {number} [ms=0]
 */
__exports.patchDate = patchDate; function patchDate(year, month, day, hours, minutes, seconds, ms = 0) {
    var RealDate = window.Date;
    var actualDate = new RealDate();

    // By default, RealDate uses the browser offset, so we must replace it with the offset fixed in luxon.
    var fakeDate = new RealDate(year, month, day, hours, minutes, seconds, ms);
    if (!(luxon.Settings.defaultZone instanceof luxon.FixedOffsetZone)) {
        throw new Error("luxon.Settings.defaultZone must be a FixedOffsetZone");
    }
    const browserOffset = -fakeDate.getTimezoneOffset();
    const patchedOffset = luxon.Settings.defaultZone.offset();
    const offsetDiff = patchedOffset - browserOffset;
    const correctedMinutes = fakeDate.getMinutes() - offsetDiff;
    fakeDate.setMinutes(correctedMinutes);

    var timeInterval = actualDate.getTime() - fakeDate.getTime();

    // eslint-disable-next-line no-global-assign
    window.Date = (function (NativeDate) {
        function Date(Y, M, D, h, m, s, ms) {
            var length = arguments.length;
            let date;
            if (arguments.length > 0) {
                date =
                    length == 1 && String(Y) === Y // isString(Y)
                        ? // We explicitly pass it through parse:
                          new NativeDate(Date.parse(Y))
                        : // We have to manually make calls depending on argument
                        // length here
                        length >= 7
                        ? new NativeDate(Y, M, D, h, m, s, ms)
                        : length >= 6
                        ? new NativeDate(Y, M, D, h, m, s)
                        : length >= 5
                        ? new NativeDate(Y, M, D, h, m)
                        : length >= 4
                        ? new NativeDate(Y, M, D, h)
                        : length >= 3
                        ? new NativeDate(Y, M, D)
                        : length >= 2
                        ? new NativeDate(Y, M)
                        : length >= 1
                        ? new NativeDate(Y)
                        : new NativeDate();
                // Prevent mixups with unfixed Date object
                date.constructor = Date;
                return date;
            } else {
                date = new NativeDate();
                var time = date.getTime();
                time -= timeInterval;
                date.setTime(time);
                return date;
            }
        }

        // Copy any custom methods a 3rd party library may have added
        for (var key in NativeDate) {
            Date[key] = NativeDate[key];
        }

        // Copy "native" methods explicitly; they may be non-enumerable
        // exception: 'now' uses fake date as reference
        Date.now = function () {
            var date = new NativeDate();
            var time = date.getTime();
            time -= timeInterval;
            return time;
        };
        Date.UTC = NativeDate.UTC;
        Date.prototype = NativeDate.prototype;
        Date.prototype.constructor = Date;

        // Upgrade Date.parse to handle simplified ISO 8601 strings
        Date.parse = NativeDate.parse;
        return Date;
    })(Date);

    registerCleanup(() => {
        window.Date = RealDate;
    });
}

/**
 * Applies a fixed time zone to luxon based on an offset to the UTC time zone.
 *
 * @param {number} offset the number of minutes ahead or behind the UTC time zone
 *                          +120 => UTC+2
 *                          -120 => UTC-2
 */
__exports.patchTimeZone = patchTimeZone; function patchTimeZone(offset) {
    patchWithCleanup(luxon.Settings, { defaultZone: luxon.FixedOffsetZone.instance(offset) });
}

/**
 *
 * @param {Object} obj object to patch
 * @param {Object} patchValue the actual patch description
 */
__exports.patchWithCleanup = patchWithCleanup; function patchWithCleanup(obj, patchValue) {
    const unpatch = patch(obj, patchValue);
    registerCleanup(() => {
        unpatch();
    });
}

/**
 * @returns {Element}
 */
__exports.getFixture = getFixture; function getFixture() {
    if (!window.QUnit) {
        return document;
    }
    if (QUnit.config.debug) {
        return document.body;
    } else {
        return document.getElementById("qunit-fixture");
    }
}

__exports.nextTick = nextTick; async function nextTick() {
    await new Promise((resolve) => window.requestAnimationFrame(resolve));
    await new Promise((resolve) => setTimeout(resolve));
}

__exports.makeDeferred = makeDeferred; function makeDeferred() {
    return new Deferred();
}

__exports.findElement = findElement; function findElement(el, selector) {
    let target = el;
    if (selector) {
        const els = el.querySelectorAll(selector);
        if (els.length === 0) {
            throw new Error(`No element found (selector: ${selector})`);
        }
        if (els.length > 1) {
            throw new Error(`Found ${els.length} elements, instead of 1 (selector: ${selector})`);
        }
        target = els[0];
    }
    return target;
}

//-----------------------------------------------------------------------------
// Event init attributes mappers
//-----------------------------------------------------------------------------

/** @param {EventInit} [args] */
const mapBubblingEvent = (args) => ({ ...args, bubbles: true });

/** @param {EventInit} [args] */
const mapNonBubblingEvent = (args) => ({ ...args, bubbles: false });

/** @param {EventInit} [args={}] */
const mapBubblingPointerEvent = (args = {}) => ({
    clientX: args.pageX,
    clientY: args.pageY,
    ...args,
    bubbles: true,
    cancelable: true,
    view: window,
});

/** @param {EventInit} [args] */
const mapNonBubblingPointerEvent = (args) => ({
    ...mapBubblingPointerEvent(args),
    bubbles: false,
    cancelable: false,
});

/** @param {EventInit} [args={}] */
const mapCancelableTouchEvent = (args = {}) => ({
    ...args,
    bubbles: true,
    cancelable: true,
    composed: true,
    rotation: 0.0,
    touches: args.touches ? [...args.touches.map((e) => new Touch(e))] : undefined,
    view: window,
    zoom: 1.0,
});

/** @param {EventInit} [args] */
const mapNonCancelableTouchEvent = (args) => ({
    ...mapCancelableTouchEvent(args),
    cancelable: false,
});

/** @param {EventInit} [args] */
const mapKeyboardEvent = (args) => ({
    ...args,
    bubbles: true,
    cancelable: true,
});

/**
 * @template {typeof Event} T
 * @param {EventType} eventType
 * @returns {[T, (attrs: EventInit) => EventInit]}
 */
const getEventConstructor = (eventType) => {
    switch (eventType) {
        // Mouse events
        case "auxclick":
        case "click":
        case "contextmenu":
        case "dblclick":
        case "mousedown":
        case "mouseup":
        case "mousemove":
        case "mouseover":
        case "mouseout": {
            return [MouseEvent, mapBubblingPointerEvent];
        }
        case "mouseenter":
        case "mouseleave": {
            return [MouseEvent, mapNonBubblingPointerEvent];
        }
        // Pointer events
        case "pointerdown":
        case "pointerup":
        case "pointermove":
        case "pointerover":
        case "pointerout": {
            return [PointerEvent, mapBubblingPointerEvent];
        }
        case "pointerenter":
        case "pointerleave": {
            return [PointerEvent, mapNonBubblingPointerEvent];
        }
        // Focus events
        case "focusin": {
            return [FocusEvent, mapBubblingEvent];
        }
        case "focus":
        case "blur": {
            return [FocusEvent, mapNonBubblingEvent];
        }
        // Clipboard events
        case "cut":
        case "copy":
        case "paste": {
            return [ClipboardEvent, mapBubblingEvent];
        }
        // Keyboard events
        case "keydown":
        case "keypress":
        case "keyup": {
            return [KeyboardEvent, mapKeyboardEvent];
        }
        // Drag events
        case "drag":
        case "dragend":
        case "dragenter":
        case "dragstart":
        case "dragleave":
        case "dragover":
        case "drop": {
            return [DragEvent, mapBubblingEvent];
        }
        // Input events
        case "input": {
            return [InputEvent, mapBubblingEvent];
        }
        // Composition events
        case "compositionstart":
        case "compositionend": {
            return [CompositionEvent, mapBubblingEvent];
        }
        // UI events
        case "scroll": {
            return [UIEvent, mapNonBubblingEvent];
        }
        // Touch events
        case "touchstart":
        case "touchend":
        case "touchmove": {
            return [TouchEvent, mapCancelableTouchEvent];
        }
        case "touchcancel": {
            return [TouchEvent, mapNonCancelableTouchEvent];
        }
        // Default: base Event constructor
        default: {
            return [Event, mapBubblingEvent];
        }
    }
};

/**
 * @template {EventType} T
 * @param {Element} el
 * @param {string | null | undefined | false} selector
 * @param {T} eventType
 * @param {EventInit} [eventInit]
 * @param {TriggerEventOptions} [options={}]
 * @returns {GlobalEventHandlersEventMap[T] | Promise<GlobalEventHandlersEventMap[T]>}
 */
__exports.triggerEvent = triggerEvent; function triggerEvent(el, selector, eventType, eventInit, options = {}) {
    const errors = [];
    const target = findElement(el, selector);

    // Error handling
    if (typeof eventType !== "string") {
        errors.push("event type must be a string");
    }
    if (!target) {
        errors.push("cannot find target");
    } else if (!options.skipVisibilityCheck && !isVisible(target)) {
        errors.push("target is not visible");
    }
    if (errors.length) {
        throw new Error(
            `Cannot trigger event${eventType ? ` "${eventType}"` : ""}${
                selector ? ` (with selector "${selector}")` : ""
            }: ${errors.join(" and ")}`
        );
    }

    // Actual dispatch
    const [Constructor, processParams] = getEventConstructor(eventType);
    const event = new Constructor(eventType, processParams(eventInit));
    target.dispatchEvent(event);

    if (window.QUnit && QUnit.config.debug) {
        const group = `%c[${event.type.toUpperCase()}]`;
        console.groupCollapsed(group, "color: #b52c9b");
        console.log(target, event);
        console.groupEnd(group, "color: #b52c9b");
    }

    if (options.sync) {
        return event;
    } else {
        return nextTick().then(() => event);
    }
}

/**
 * @param {Element} el
 * @param {string | null | undefined | false} selector
 * @param {(EventType | [EventType, EventInit])[]} [eventDefs]
 * @param {TriggerEventOptions} [options={}]
 */
__exports.triggerEvents = triggerEvents; function triggerEvents(el, selector, eventDefs, options = {}) {
    const events = [...eventDefs].map((eventDef) => {
        const [eventType, eventInit] = Array.isArray(eventDef) ? eventDef : [eventDef, {}];
        return triggerEvent(el, selector, eventType, eventInit, options);
    });
    if (options.sync) {
        return events;
    } else {
        return nextTick().then(() => events);
    }
}

/**
 * Triggers a scroll event on the given target
 *
 * If the target cannot be scrolled or an axis has reached
 * the end of the scrollable area, the event can be transmitted
 * to its nearest parent until it can be triggered
 *
 * @param {Element} target target of the scroll event
 * @param {Object} coordinates
 * @param {number} coordinates.left coordinates to scroll horizontally
 * @param {number} coordinates.top coordinates to scroll vertically
 * @param {boolean} canPropagate states if the scroll can propagate to a scrollable parent
 */
__exports.triggerScroll = triggerScroll; async function triggerScroll(
    target,
    coordinates = { left: null, top: null },
    canPropagate = true
) {
    const isScrollable =
        (target.scrollHeight > target.clientHeight && target.clientHeight > 0) ||
        (target.scrollWidth > target.clientWidth && target.clientWidth > 0);
    if (!isScrollable && !canPropagate) {
        return;
    }
    if (isScrollable) {
        const canScrollFrom = {
            left:
                coordinates.left > target.scrollLeft
                    ? target.scrollLeft + target.clientWidth < target.scrollWidth
                    : target.scrollLeft > 0,
            top:
                coordinates.top > target.scrollTop
                    ? target.scrollTop + target.clientHeight < target.scrollHeight
                    : target.scrollTop > 0,
        };
        const scrollCoordinates = {};
        Object.entries(coordinates).forEach(([key, value]) => {
            if (value !== null && canScrollFrom[key]) {
                scrollCoordinates[key] = value;
                delete coordinates[key];
            }
        });
        target.scrollTo(scrollCoordinates);
        await triggerEvent(target, null, "scroll");
        if (!canPropagate || !Object.entries(coordinates).length) {
            return;
        }
    }
    target.parentElement
        ? triggerScroll(target.parentElement, coordinates)
        : triggerEvent(window, null, "scroll");
    await nextTick();
}

__exports.click = click; function click(
    el,
    selector,
    { mouseEventInit = {}, skipDisabledCheck = false, skipVisibilityCheck = false } = {}
) {
    if (!skipDisabledCheck && el.disabled) {
        throw new Error("Can't click on a disabled button");
    }
    return triggerEvents(
        el,
        selector,
        [
            "pointerdown",
            "mousedown",
            "focus",
            "focusin",
            "pointerup",
            "mouseup",
            ["click", mouseEventInit],
        ],
        { skipVisibilityCheck }
    );
}

__exports.clickCreate = clickCreate; function clickCreate(htmlElement) {
    if (
        htmlElement.querySelectorAll(
            ".o_control_panel_main_buttons .o_form_button_create"
        ).length
    ) {
        return click(
            htmlElement,
            ".o_control_panel_main_buttons .o_form_button_create"
        );
    } else if (
        htmlElement.querySelectorAll(
            ".o_control_panel_main_buttons .o_list_button_create"
        ).length
    ) {
        return click(
            htmlElement,
            ".o_control_panel_main_buttons .o_list_button_create"
        );
    } else {
        throw new Error("No edit button found to be clicked.");
    }
}

__exports.clickEdit = clickEdit; function clickEdit(htmlElement) {
    if (htmlElement.querySelectorAll(".o_list_button_edit").length) {
        return click(htmlElement, ".o_list_button_edit");
    } else {
        throw new Error("No edit button found to be clicked.");
    }
}

__exports.clickSave = clickSave; async function clickSave(htmlElement) {
    if (htmlElement.querySelectorAll(".o_form_status_indicator").length) {
        await mouseEnter(htmlElement, ".o_form_status_indicator");
    }
    if (htmlElement.querySelectorAll(".o_form_button_save").length) {
        return click(htmlElement, ".o_form_button_save");
    }
    const listSaveButtons = htmlElement.querySelectorAll(".o_list_button_save");
    if (listSaveButtons.length) {
        return listSaveButtons.length >= 2 ? click(listSaveButtons[1]) : click(listSaveButtons[0]);
    } else {
        throw new Error("No save button found to be clicked.");
    }
}

__exports.clickDiscard = clickDiscard; async function clickDiscard(htmlElement) {
    if (htmlElement.querySelectorAll(".o_form_status_indicator").length) {
        await mouseEnter(htmlElement, ".o_form_status_indicator");
    }
    if (htmlElement.querySelectorAll(".o_form_button_cancel").length) {
        return click(htmlElement, ".o_form_button_cancel");
    } else if ($(htmlElement).find(".o_list_button_discard:visible").length) {
        return click($(htmlElement).find(".o_list_button_discard:visible").get(0));
    } else {
        throw new Error("No discard button found to be clicked.");
    }
}

/**
 * Trigger pointerenter and mouseenter events on the given target. If no
 * coordinates are given, the event is located by default
 * in the middle of the target to simplify the test process
 *
 * @param {Element} el
 * @param {string} selector
 * @param {Object} coordinates position of the mouseenter event
 */
__exports.mouseEnter = mouseEnter; async function mouseEnter(el, selector, coordinates) {
    const target = el.querySelector(selector) || el;
    const atPos = coordinates || {
        clientX: target.getBoundingClientRect().left + target.getBoundingClientRect().width / 2,
        clientY: target.getBoundingClientRect().top + target.getBoundingClientRect().height / 2,
    };
    return triggerEvents(target, null, ["pointerenter", "mouseenter"], atPos);
}

/**
 * Trigger pointerleave and mouseleave events on the given target.
 *
 * @param {Element} el
 * @param {string} selector
 */
__exports.mouseLeave = mouseLeave; async function mouseLeave(el, selector) {
    const target = el.querySelector(selector) || el;
    return triggerEvents(target, null, ["pointerleave", "mouseleave"]);
}

__exports.editInput = editInput; async function editInput(el, selector, value) {
    const input = findElement(el, selector);
    if (!(input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement)) {
        throw new Error("Only 'input' and 'textarea' elements can be edited with 'editInput'.");
    }
    if (
        !["text", "textarea", "email", "search", "color", "number", "file", "tel"].includes(
            input.type
        )
    ) {
        throw new Error(`Type "${input.type}" not supported by 'editInput'.`);
    }

    const eventOpts = {};
    if (input.type === "file") {
        const files = Array.isArray(value) ? value : [value];
        const dataTransfer = new DataTransfer();
        for (const file of files) {
            if (!(file instanceof File)) {
                throw new Error(`File input value should be one or several File objects.`);
            }
            dataTransfer.items.add(file);
        }
        input.files = dataTransfer.files;
        eventOpts.skipVisibilityCheck = true;
    } else {
        input.value = value;
    }

    await triggerEvents(input, null, ["input", "change"], eventOpts);

    if (input.type === "file") {
        // Need to wait for the file to be loaded by the input
        await nextTick();
        await nextTick();
    }
}

__exports.editSelect = editSelect; function editSelect(el, selector, value) {
    const select = findElement(el, selector);
    if (select.tagName !== "SELECT") {
        throw new Error("Only select tag can be edited with selectInput.");
    }
    select.value = value;
    return triggerEvent(select, null, "change");
}

__exports.editSelectMenu = editSelectMenu; async function editSelectMenu(el, selector, value) {
    const dropdown = el.querySelector(selector);
    await click(dropdown.querySelector(".dropdown-toggle"));
    for (const item of Array.from(el.querySelectorAll(".o_select_menu_menu .dropdown-item"))) {
        if (item.textContent === value) {
            return click(item);
        }
    }
}

/**
 * Triggers an hotkey properly disregarding the operating system.
 *
 * @param {string} hotkey
 * @param {boolean} addOverlayModParts
 * @param {KeyboardEventInit} eventAttrs
 */
__exports.triggerHotkey = triggerHotkey; async function triggerHotkey(hotkey, addOverlayModParts = false, eventAttrs = {}) {
    eventAttrs.key = hotkey.split("+").pop();

    if (/shift/i.test(hotkey)) {
        eventAttrs.shiftKey = true;
    }

    if (/control/i.test(hotkey)) {
        if (isMacOS()) {
            eventAttrs.metaKey = true;
        } else {
            eventAttrs.ctrlKey = true;
        }
    }

    if (/alt/i.test(hotkey) || addOverlayModParts) {
        if (isMacOS()) {
            eventAttrs.ctrlKey = true;
        } else {
            eventAttrs.altKey = true;
        }
    }

    if (!("bubbles" in eventAttrs)) {
        eventAttrs.bubbles = true;
    }

    const [keydownEvent, keyupEvent] = await triggerEvents(
        document.activeElement,
        null,
        [
            ["keydown", eventAttrs],
            ["keyup", eventAttrs],
        ],
        { skipVisibilityCheck: true }
    );

    return { keydownEvent, keyupEvent };
}

__exports.mockDownload = mockDownload; function mockDownload(cb) {
    patchWithCleanup(download, { _download: cb });
}

const hushConsole = __exports.hushConsole = Object.create(null);
for (const propName of Object.keys(window.console)) {
    hushConsole[propName] = () => {};
}

__exports.mockSendBeacon = mockSendBeacon; function mockSendBeacon(mock) {
    patchWithCleanup(navigator, {
        sendBeacon: (url, blob) => {
            return mock(url, blob) !== false;
        },
    });
}

__exports.mockTimeout = mockTimeout; function mockTimeout() {
    const timeouts = new Map();
    let currentTime = 0;
    let id = 1;
    patchWithCleanup(browser, {
        setTimeout(fn, delay = 0) {
            timeouts.set(id, { fn, scheduledFor: delay + currentTime, id });
            return id++;
        },
        clearTimeout(id) {
            timeouts.delete(id);
        },
    });
    return {
        execRegisteredTimeouts() {
            for (const { fn } of timeouts.values()) {
                fn();
            }
            timeouts.clear();
        },
        async advanceTime(duration) {
            // wait here so all microtasktick scheduled in this frame can be
            // executed and possibly register their own timeout
            await nextTick();
            currentTime += duration;
            for (const { fn, scheduledFor, id } of timeouts.values()) {
                if (scheduledFor <= currentTime) {
                    fn();
                    timeouts.delete(id);
                }
            }
            // wait here to make sure owl can update the UI
            await nextTick();
        },
    };
}

__exports.mockAnimationFrame = mockAnimationFrame; function mockAnimationFrame() {
    const callbacks = new Map();
    let currentTime = 0;
    let id = 1;
    patchWithCleanup(browser, {
        requestAnimationFrame(fn) {
            callbacks.set(id, { fn, scheduledFor: 16 + currentTime, id });
            return id++;
        },
        cancelAnimationFrame(id) {
            callbacks.delete(id);
        },
        performance: { now: () => currentTime },
    });
    return {
        execRegisteredAnimationFrames() {
            for (const { fn } of callbacks.values()) {
                fn(currentTime);
            }
            callbacks.clear();
        },
        async advanceFrame(count = 1) {
            // wait here so all microtasktick scheduled in this frame can be
            // executed and possibly register their own timeout
            await nextTick();
            currentTime += 16 * count;
            for (const { fn, scheduledFor, id } of callbacks.values()) {
                if (scheduledFor <= currentTime) {
                    fn(currentTime);
                    callbacks.delete(id);
                }
            }
            // wait here to make sure owl can update the UI
            await nextTick();
        },
    };
}

__exports.mount = mount; async function mount(Comp, target, config = {}) {
    let { props, env } = config;
    env = env || {};
    const configuration = {
        env,
        getTemplate,
        test: true,
        props,
    };
    if (env.services && "localization" in env.services) {
        configuration.translateFn = _t;
    }
    const app = new App(Comp, configuration);
    registerCleanup(() => app.destroy());
    return app.mount(target);
}

__exports.destroy = destroy; function destroy(comp) {
    comp.__owl__.app.destroy();
}

__exports.findChildren = findChildren; function findChildren(comp, predicate = (e) => e) {
    const queue = [];
    [].unshift.apply(queue, Object.values(comp.__owl__.children));

    while (queue.length > 0) {
        const curNode = queue.pop();
        if (predicate(curNode)) {
            return curNode;
        }
        [].unshift.apply(queue, Object.values(curNode.component.__owl__.children));
    }
}

// partial replacement of t-ref on component
__exports.useChild = useChild; function useChild() {
    const node = useComponent().__owl__;
    const setChild = () => {
        const componentNode = Object.values(node.children)[0];
        node.component.child = componentNode.component;
    };
    onMounted(setChild);
    onPatched(setChild);
}

__exports.useLogLifeCycle = useLogLifeCycle; function useLogLifeCycle(logFn, name = "") {
    const component = useComponent();
    let loggedName = `${component.constructor.name}`;
    if (name) {
        loggedName = `${component.constructor.name} ${name}`;
    }
    onError(() => {
        logFn(`onError ${loggedName}`);
    });
    onMounted(() => {
        logFn(`onMounted ${loggedName}`);
    });
    onPatched(() => {
        logFn(`onPatched ${loggedName}`);
    });
    onRendered(() => {
        logFn(`onRendered ${loggedName}`);
    });
    onWillDestroy(() => {
        logFn(`onWillDestroy ${loggedName}`);
    });
    onWillPatch(() => {
        logFn(`onWillPatch ${loggedName}`);
    });
    onWillRender(() => {
        logFn(`onWillRender ${loggedName}`);
    });
    onWillStart(() => {
        logFn(`onWillStart ${loggedName}`);
    });
    onWillUnmount(() => {
        logFn(`onWillUnmount ${loggedName}`);
    });
    onWillUpdateProps(() => {
        logFn(`onWillUpdateProps ${loggedName}`);
    });
}

/**
 * Returns the list of nodes containing n2 (included) that do not contain n1.
 *
 * @param {Node} n1
 * @param {Node} n2
 * @returns {Node[]}
 */
function getDifferentParents(n1, n2) {
    const parents = [n2];
    while (parents[0].parentNode) {
        const parent = parents[0].parentNode;
        if (parent.contains(n1)) {
            break;
        }
        parents.unshift(parent);
    }
    return parents;
}

/**
 * Helper performing a drag and drop sequence.
 *
 * - 'from' is used to determine the element on which the drag will start;
 * - 'target' will determine the element on which the first one will be dropped.
 *
 * The first element will be dragged by its center, and will be dropped on the
 * bottom-right inner pixel of the target element. This behavior covers both
 * cases of appending the first element to the end of a list (toSelector =
 * target list) or moving it at the position of another element, effectively
 * placing the first element before the second (toSelector = other element).
 *
 * A position can be given to drop the first element above, below, or on the
 * side of the second (default is inside, as specified above).
 *
 * Note that only the last event is awaited, since all the others are
 * considered to be synchronous.
 *
 * @param {Element | string} from
 * @param {Element | string} to
 * @param {Position} [position]
 */
__exports.dragAndDrop = dragAndDrop; async function dragAndDrop(from, to, position) {
    const { drop } = await drag(from);
    await drop(to, position);
}

/**
 * Helper performing a drag.
 *
 * - the 'from' selector is used to determine the element on which the drag will
 *  start;
 * - the 'target' selector will determine the element on which the dragged element will be
 * moved.
 *
 * Returns a drop function
 *
 * @param {Element | string} from
 */
__exports.drag = drag; async function drag(from, pointerType = "mouse") {
    const assertIsDragging = (fn, endDrag) => {
        return {
            async [fn.name](...args) {
                if (dragEndReason) {
                    throw new Error(
                        `Cannot execute drag helper '${fn.name}': drag sequence has been ended by '${dragEndReason}'.`
                    );
                }
                await fn(...args);
                if (endDrag) {
                    dragEndReason = fn.name;
                }
            },
        }[fn.name];
    };

    const cancel = assertIsDragging(async function cancel() {
        await triggerEvent(window, null, "keydown", { key: "Escape" });
    }, true);

    /**
     * @param {Element | string} [to]
     * @param {Position} [position]
     */
    const drop = assertIsDragging(async function drop(to, position) {
        if (to) {
            await moveTo(to, position);
        }
        await triggerEvent(target || source, null, "pointerup", targetPosition);
    }, true);

    /**
     * @param {Element | string} selector
     */
    const getEl = (selector) =>
        selector instanceof Element ? selector : fixture.querySelector(selector);

    /**
     * @param {Position} [position]
     */
    const getTargetPosition = (position) => {
        const tRect = target.getBoundingClientRect();
        const tPos = {
            clientX: Math.floor(tRect.x),
            clientY: Math.floor(tRect.y),
        };
        if (position && typeof position === "object") {
            // x and y coordinates start from the element's initial coordinates
            tPos.clientX += position.x || 0;
            tPos.clientY += position.y || 0;
        } else {
            const positions = typeof position === "string" ? position.split("-") : [];

            // X position
            if (positions.includes("left")) {
                tPos.clientX -= 1;
            } else if (positions.includes("right")) {
                tPos.clientX += Math.ceil(tRect.width) + 1;
            } else {
                tPos.clientX += Math.floor(tRect.width / 2);
            }

            // Y position
            if (positions.includes("top")) {
                tPos.clientY -= 1;
            } else if (positions.includes("bottom")) {
                tPos.clientY += Math.ceil(tRect.height) + 1;
            } else {
                tPos.clientY += Math.floor(tRect.height / 2);
            }
        }
        return tPos;
    };

    /**
     * @param {Element | string} [to]
     * @param {Position} [position]
     */
    const moveTo = assertIsDragging(async function moveTo(to, position) {
        target = getEl(to);
        if (!target) {
            return;
        }

        // Recompute target position
        targetPosition = getTargetPosition(position);

        // Move, enter and drop the element on the target
        await triggerEvent(source, null, "pointermove", { ...targetPosition, button: -1 });

        // "pointerenter" is fired on every parent of `target` that do not contain
        // `from` (typically: different parent lists).
        for (const parent of getDifferentParents(source, target)) {
            triggerEvent(parent, null, "pointerenter", targetPosition);
        }
        await nextTick();

        return dragHelpers;
    }, false);

    const dragHelpers = { cancel, drop, moveTo };
    const fixture = getFixture();

    const source = getEl(from instanceof Element ? from : fixture.querySelector(from));
    const sourceRect = source.getBoundingClientRect();

    let dragEndReason = null;
    let target;
    let targetPosition;

    // Pointer down on main target
    await triggerEvent(source, null, "pointerdown", {
        pointerType,
        clientX: sourceRect.x + sourceRect.width / 2,
        clientY: sourceRect.y + sourceRect.height / 2,
    });

    return dragHelpers;
}

/**
 * Returns the dropdown menu for a specific toggler.
 *
 * @param {HTMLElement} target
 * @param {String|HTMLElement} togglerSelector
 * @returns {HTMLElement|undefined}
 */
__exports.getDropdownMenu = getDropdownMenu; function getDropdownMenu(target, togglerSelector) {
    if (!(target instanceof HTMLElement)) {
        throw new Error(`getDropdownMenu: target is not an HTMLElement.`);
    }
    let el =
        togglerSelector instanceof HTMLElement
            ? togglerSelector
            : target.querySelector(togglerSelector);

    if (el && !el.classList.contains("o-dropdown")) {
        el = el.querySelector(".o-dropdown");
    }
    if (!el) {
        throw new Error(`getDropdownMenu: Could not find element "${togglerSelector}".`);
    }
    return getPopoverForTarget(el);
}

__exports.clickDropdown = clickDropdown; async function clickDropdown(target, fieldName) {
    const dropdownInput = target.querySelector(`[name='${fieldName}'] .dropdown input`);
    dropdownInput.focus();
    await nextTick();
    await click(dropdownInput);
}

__exports.clickOpenedDropdownItem = clickOpenedDropdownItem; async function clickOpenedDropdownItem(target, fieldName, itemContent) {
    const dropdowns = target.querySelectorAll(`[name='${fieldName}'] .dropdown .dropdown-menu`);
    if (dropdowns.length === 0) {
        throw new Error(`No dropdown found for field ${fieldName}`);
    } else if (dropdowns.length > 1) {
        throw new Error(`Found ${dropdowns.length} dropdowns for field ${fieldName}`);
    }
    const dropdownItems = dropdowns[0].querySelectorAll("li");
    const indexToClick = Array.from(dropdownItems)
        .map((html) => html.textContent)
        .indexOf(itemContent);
    if (indexToClick === -1) {
        throw new Error(`The element '${itemContent}' does not exist in the dropdown`);
    }
    await click(dropdownItems[indexToClick]);
}

__exports.selectDropdownItem = selectDropdownItem; async function selectDropdownItem(target, fieldName, itemContent) {
    await clickDropdown(target, fieldName);
    await clickOpenedDropdownItem(target, fieldName, itemContent);
}

__exports.getNodesTextContent = getNodesTextContent; function getNodesTextContent(nodes) {
    return Array.from(nodes).map((n) => n.textContent);
}

/**
 * Click to open the dropdown on a many2one
 */
__exports.clickOpenM2ODropdown = clickOpenM2ODropdown; async function clickOpenM2ODropdown(el, fieldName, selector) {
    const m2oSelector = `${selector || ""} .o_field_many2one[name=${fieldName}] input`;
    const matches = el.querySelectorAll(m2oSelector);
    if (matches.length !== 1) {
        throw new Error(
            `cannot open m2o: selector ${selector} has been found ${matches.length} instead of 1`
        );
    }

    await click(matches[0]);
    return matches[0];
}

/**
 * Click on the active (highlighted) selection in a m2o dropdown.
 */
// TO FIX
__exports.clickM2OHighlightedItem = clickM2OHighlightedItem; async function clickM2OHighlightedItem(el, fieldName, selector) {
    const m2oSelector = `${selector || ""} .o_field_many2one[name=${fieldName}] input`;
    // const $dropdown = $(m2oSelector).autocomplete('widget');
    const matches = el.querySelectorAll(m2oSelector);
    if (matches.length !== 1) {
        throw new Error(
            `cannot open m2o: selector ${selector} has been found ${matches.length} instead of 1`
        );
    }
    // clicking on an li (no matter which one), will select the focussed one
    return click(matches[0].parentElement.querySelector("li"));
}

// X2Many
__exports.addRow = addRow; async function addRow(target, selector) {
    await click(target.querySelector(`${selector ? selector : ""} .o_field_x2many_list_row_add a`));
}

__exports.removeRow = removeRow; async function removeRow(target, index) {
    await click(target.querySelectorAll(".o_list_record_remove")[index]);
}

return __exports;
});

odoo.define(`@web/../tests/helpers/utils`, ['@web/../tests/legacy/helpers/utils'], function (require) {
                        return require('@web/../tests/legacy/helpers/utils');
                        });
;

/************************************************
*  Filepath: /web/static/tests/legacy/utils.js  *
*  Lines: 695                                   *
************************************************/
odoo.define('@web/../tests/legacy/utils', ['@web/core/utils/ui', '@web/../tests/helpers/cleanup', '@web/../tests/helpers/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=@web/../tests/utils default=false */

const { isVisible } = require("@web/core/utils/ui");
const { registerCleanup } = require("@web/../tests/helpers/cleanup");
const {
    click: webClick,
    getFixture,
    makeDeferred,
    triggerEvents: webTriggerEvents,
} = require("@web/../tests/helpers/utils");

/**
 * Create a fake object 'dataTransfer', linked to some files,
 * which is passed to drag and drop events.
 *
 * @param {Object[]} files
 * @returns {Object}
 */
function createFakeDataTransfer(files) {
    return {
        dropEffect: "all",
        effectAllowed: "all",
        files,
        items: [],
        types: ["Files"],
    };
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then clicks on it.
 *
 * @param {string} selector
 * @param {ContainsOptions} [options] forwarded to `contains`
 * @param {boolean} [options.shiftKey]
 */
__exports.click = click; async function click(selector, options = {}) {
    const { shiftKey } = options;
    delete options.shiftKey;
    await contains(selector, { click: { shiftKey }, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then dragenters `files` on it.
 *
 * @param {string} selector
 * @param {Object[]} files
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.dragenterFiles = dragenterFiles; async function dragenterFiles(selector, files, options) {
    await contains(selector, { dragenterFiles: files, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then dragovers `files` on it.
 *
 * @param {string} selector
 * @param {Object[]} files
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.dragoverFiles = dragoverFiles; async function dragoverFiles(selector, files, options) {
    await contains(selector, { dragoverFiles: files, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then drops `files` on it.
 *
 * @param {string} selector
 * @param {Object[]} files
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.dropFiles = dropFiles; async function dropFiles(selector, files, options) {
    await contains(selector, { dropFiles: files, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then inputs `files` on it.
 *
 * @param {string} selector
 * @param {Object[]} files
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.inputFiles = inputFiles; async function inputFiles(selector, files, options) {
    await contains(selector, { inputFiles: files, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then pastes `files` on it.
 *
 * @param {string} selector
 * @param {Object[]} files
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.pasteFiles = pasteFiles; async function pasteFiles(selector, files, options) {
    await contains(selector, { pasteFiles: files, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then focuses on it.
 *
 * @param {string} selector
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.focus = focus; async function focus(selector, options) {
    await contains(selector, { setFocus: true, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then inserts the given `content`.
 *
 * @param {string} selector
 * @param {string} content
 * @param {ContainsOptions} [options] forwarded to `contains`
 * @param {boolean} [options.replace=false]
 */
__exports.insertText = insertText; async function insertText(selector, content, options = {}) {
    const { replace = false } = options;
    delete options.replace;
    await contains(selector, { ...options, insertText: { content, replace } });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then sets its `scrollTop` to the given value.
 *
 * @param {string} selector
 * @param {number|"bottom"} scrollTop
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.scroll = scroll; async function scroll(selector, scrollTop, options) {
    await contains(selector, { setScroll: scrollTop, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then triggers `event` on it.
 *
 * @param {string} selector
 * @param {(import("@web/../tests/helpers/utils").EventType|[import("@web/../tests/helpers/utils").EventType, EventInit])[]} events
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.triggerEvents = triggerEvents; async function triggerEvents(selector, events, options) {
    await contains(selector, { triggerEvents: events, ...options });
}

function log(ok, message) {
    if (window.QUnit) {
        QUnit.assert.ok(ok, message);
    } else {
        if (ok) {
            console.log(message);
        } else {
            console.error(message);
        }
    }
}

let hasUsedContainsPositively = false;
if (window.QUnit) {
    QUnit.testStart(() => (hasUsedContainsPositively = false));
}
/**
 * @typedef {[string, ContainsOptions]} ContainsTuple tuple representing params of the contains
 *  function, where the first element is the selector, and the second element is the options param.
 * @typedef {Object} ContainsOptions
 * @property {ContainsTuple} [after] if provided, the found element(s) must be after the element
 *  matched by this param.
 * @property {ContainsTuple} [before] if provided, the found element(s) must be before the element
 *  matched by this param.
 * @property {Object} [click] if provided, clicks on the first found element
 * @property {ContainsTuple|ContainsTuple[]} [contains] if provided, the found element(s) must
 *  contain the provided sub-elements.
 * @property {number} [count=1] numbers of elements to be found to declare the contains check
 *  as successful. Elements are counted after applying all other filters.
 * @property {Object[]} [dragenterFiles] if provided, dragenters the given files on the found element
 * @property {Object[]} [dragoverFiles] if provided, dragovers the given files on the found element
 * @property {Object[]} [dropFiles] if provided, drops the given files on the found element
 * @property {Object[]} [inputFiles] if provided, inputs the given files on the found element
 * @property {{content:string, replace:boolean}} [insertText] if provided, adds to (or replace) the
 *  value of the first found element by the given content.
 * @property {ContainsTuple} [parent] if provided, the found element(s) must have as
 *  parent the node matching the parent parameter.
 * @property {Object[]} [pasteFiles] if provided, pastes the given files on the found element
 * @property {number|"bottom"} [scroll] if provided, the scrollTop of the found element(s)
 *  must match.
 *  Note: when using one of the scrollTop options, it is advised to ensure the height is not going
 *  to change soon, by checking with a preceding contains that all the expected elements are in DOM.
 * @property {boolean} [setFocus] if provided, focuses the first found element.
 * @property {boolean} [shadowRoot] if provided, targets the shadowRoot of the found elements.
 * @property {number|"bottom"} [setScroll] if provided, sets the scrollTop on the first found
 *  element.
 * @property {HTMLElement} [target=getFixture()]
 * @property {string[]} [triggerEvents] if provided, triggers the given events on the found element
 * @property {string} [text] if provided, the textContent of the found element(s) or one of their
 *  descendants must match. Use `textContent` option for a match on the found element(s) only.
 * @property {string} [textContent] if provided, the textContent of the found element(s) must match.
 *  Prefer `text` option for a match on the found element(s) or any of their descendants, usually
 *  allowing for a simpler and less specific selector.
 * @property {string} [value] if provided, the input value of the found element(s) must match.
 *  Note: value changes are not observed directly, another mutation must happen to catch them.
 * @property {boolean} [visible] if provided, the found element(s) must be (in)visible
 */
class Contains {
    /**
     * @param {string} selector
     * @param {ContainsOptions} [options={}]
     */
    constructor(selector, options = {}) {
        this.selector = selector;
        this.options = options;
        this.options.count ??= 1;
        this.options.targetParam = this.options.target;
        this.options.target ??= getFixture();
        let selectorMessage = `${this.options.count} of "${this.selector}"`;
        if (this.options.visible !== undefined) {
            selectorMessage = `${selectorMessage} ${
                this.options.visible ? "visible" : "invisible"
            }`;
        }
        if (this.options.targetParam) {
            selectorMessage = `${selectorMessage} inside a specific target`;
        }
        if (this.options.parent) {
            selectorMessage = `${selectorMessage} inside a specific parent`;
        }
        if (this.options.contains) {
            selectorMessage = `${selectorMessage} with a specified sub-contains`;
        }
        if (this.options.text !== undefined) {
            selectorMessage = `${selectorMessage} with text "${this.options.text}"`;
        }
        if (this.options.textContent !== undefined) {
            selectorMessage = `${selectorMessage} with textContent "${this.options.textContent}"`;
        }
        if (this.options.value !== undefined) {
            selectorMessage = `${selectorMessage} with value "${this.options.value}"`;
        }
        if (this.options.scroll !== undefined) {
            selectorMessage = `${selectorMessage} with scroll "${this.options.scroll}"`;
        }
        if (this.options.after !== undefined) {
            selectorMessage = `${selectorMessage} after a specified element`;
        }
        if (this.options.before !== undefined) {
            selectorMessage = `${selectorMessage} before a specified element`;
        }
        this.selectorMessage = selectorMessage;
        if (this.options.contains && !Array.isArray(this.options.contains[0])) {
            this.options.contains = [this.options.contains];
        }
        if (this.options.count) {
            hasUsedContainsPositively = true;
        } else if (!hasUsedContainsPositively) {
            throw new Error(
                `Starting a test with "contains" of count 0 for selector "${this.selector}" is useless because it might immediately resolve. Start the test by checking that an expected element actually exists.`
            );
        }
        /** @type {string} */
        this.successMessage = undefined;
        /** @type {function} */
        this.executeError = undefined;
    }

    /**
     * Starts this contains check, either immediately resolving if there is a
     * match, or registering appropriate listeners and waiting until there is a
     * match or a timeout (resolving or rejecting respectively).
     *
     * Success or failure messages will be logged with QUnit as well.
     *
     * @returns {Promise}
     */
    run() {
        this.done = false;
        this.def = makeDeferred();
        this.scrollListeners = new Set();
        this.onScroll = () => this.runOnce("after scroll");
        if (!this.runOnce("immediately")) {
            this.timer = setTimeout(
                () => this.runOnce("Timeout of 5 seconds", { crashOnFail: true }),
                5000
            );
            this.observer = new MutationObserver((mutations) => {
                try {
                    this.runOnce("after mutations");
                } catch (e) {
                    this.def.reject(e); // prevents infinite loop in case of programming error
                }
            });
            this.observer.observe(this.options.target, {
                attributes: true,
                childList: true,
                subtree: true,
            });
            registerCleanup(() => {
                if (!this.done) {
                    this.runOnce("Test ended", { crashOnFail: true });
                }
            });
        }
        return this.def;
    }

    /**
     * Runs this contains check once, immediately returning the result (or
     * undefined), and possibly resolving or rejecting the main promise
     * (and printing QUnit log) depending on options.
     * If undefined is returned it means the check was not successful.
     *
     * @param {string} whenMessage
     * @param {Object} [options={}]
     * @param {boolean} [options.crashOnFail=false]
     * @param {boolean} [options.executeOnSuccess=true]
     * @returns {HTMLElement[]|undefined}
     */
    runOnce(whenMessage, { crashOnFail = false, executeOnSuccess = true } = {}) {
        const res = this.select();
        if (res?.length === this.options.count || crashOnFail) {
            // clean before doing anything else to avoid infinite loop due to side effects
            this.observer?.disconnect();
            clearTimeout(this.timer);
            for (const el of this.scrollListeners ?? []) {
                el.removeEventListener("scroll", this.onScroll);
            }
            this.done = true;
        }
        if (res?.length === this.options.count) {
            this.successMessage = `Found ${this.selectorMessage} (${whenMessage})`;
            if (executeOnSuccess) {
                this.executeAction(res[0]);
            }
            return res;
        } else {
            this.executeError = () => {
                let message = `Failed to find ${this.selectorMessage} (${whenMessage}).`;
                message = res
                    ? `${message} Found ${res.length} instead.`
                    : `${message} Parent not found.`;
                if (this.parentContains) {
                    if (this.parentContains.successMessage) {
                        log(true, this.parentContains.successMessage);
                    } else {
                        this.parentContains.executeError();
                    }
                }
                log(false, message);
                this.def?.reject(new Error(message));
                for (const childContains of this.childrenContains || []) {
                    if (childContains.successMessage) {
                        log(true, childContains.successMessage);
                    } else {
                        childContains.executeError();
                    }
                }
            };
            if (crashOnFail) {
                this.executeError();
            }
        }
    }

    /**
     * Executes the action(s) given to this constructor on the found element,
     * prints the success messages, and resolves the main deferred.

     * @param {HTMLElement} el
     */
    executeAction(el) {
        let message = this.successMessage;
        if (this.options.click) {
            message = `${message} and clicked it`;
            webClick(el, undefined, {
                mouseEventInit: this.options.click,
                skipDisabledCheck: true,
                skipVisibilityCheck: true,
            });
        }
        if (this.options.dragenterFiles) {
            message = `${message} and dragentered ${this.options.dragenterFiles.length} file(s)`;
            const ev = new Event("dragenter", { bubbles: true });
            Object.defineProperty(ev, "dataTransfer", {
                value: createFakeDataTransfer(this.options.dragenterFiles),
            });
            el.dispatchEvent(ev);
        }
        if (this.options.dragoverFiles) {
            message = `${message} and dragovered ${this.options.dragoverFiles.length} file(s)`;
            const ev = new Event("dragover", { bubbles: true });
            Object.defineProperty(ev, "dataTransfer", {
                value: createFakeDataTransfer(this.options.dragoverFiles),
            });
            el.dispatchEvent(ev);
        }
        if (this.options.dropFiles) {
            message = `${message} and dropped ${this.options.dropFiles.length} file(s)`;
            const ev = new Event("drop", { bubbles: true });
            Object.defineProperty(ev, "dataTransfer", {
                value: createFakeDataTransfer(this.options.dropFiles),
            });
            el.dispatchEvent(ev);
        }
        if (this.options.inputFiles) {
            message = `${message} and inputted ${this.options.inputFiles.length} file(s)`;
            // could not use _createFakeDataTransfer as el.files assignation will only
            // work with a real FileList object.
            const dataTransfer = new window.DataTransfer();
            for (const file of this.options.inputFiles) {
                dataTransfer.items.add(file);
            }
            el.files = dataTransfer.files;
            /**
             * Changing files programatically is not supposed to trigger the event but
             * it does in Chrome versions before 73 (which is on runbot), so in that
             * case there is no need to make a manual dispatch, because it would lead to
             * the files being added twice.
             */
            const versionRaw = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
            const chromeVersion = versionRaw ? parseInt(versionRaw[2], 10) : false;
            if (!chromeVersion || chromeVersion >= 73) {
                el.dispatchEvent(new Event("change"));
            }
        }
        if (this.options.insertText !== undefined) {
            message = `${message} and inserted text "${this.options.insertText.content}" (replace: ${this.options.insertText.replace})`;
            el.focus();
            if (this.options.insertText.replace) {
                el.value = "";
                el.dispatchEvent(new window.KeyboardEvent("keydown", { key: "Backspace" }));
                el.dispatchEvent(new window.KeyboardEvent("keyup", { key: "Backspace" }));
                el.dispatchEvent(new window.InputEvent("input"));
            }
            for (const char of this.options.insertText.content) {
                el.value += char;
                el.dispatchEvent(new window.KeyboardEvent("keydown", { key: char }));
                el.dispatchEvent(new window.KeyboardEvent("keyup", { key: char }));
                el.dispatchEvent(new window.InputEvent("input"));
            }
            el.dispatchEvent(new window.InputEvent("change"));
        }
        if (this.options.pasteFiles) {
            message = `${message} and pasted ${this.options.pasteFiles.length} file(s)`;
            const ev = new Event("paste", { bubbles: true });
            Object.defineProperty(ev, "clipboardData", {
                value: createFakeDataTransfer(this.options.pasteFiles),
            });
            el.dispatchEvent(ev);
        }
        if (this.options.setFocus) {
            message = `${message} and focused it`;
            el.focus();
        }
        if (this.options.setScroll !== undefined) {
            message = `${message} and set scroll to "${this.options.setScroll}"`;
            el.scrollTop =
                this.options.setScroll === "bottom" ? el.scrollHeight : this.options.setScroll;
        }
        if (this.options.triggerEvents) {
            message = `${message} and triggered "${this.options.triggerEvents.join(", ")}" events`;
            webTriggerEvents(el, null, this.options.triggerEvents, {
                skipVisibilityCheck: true,
            });
        }
        if (this.parentContains) {
            log(true, this.parentContains.successMessage);
        }
        log(true, message);
        for (const childContains of this.childrenContains) {
            log(true, childContains.successMessage);
        }
        this.def?.resolve();
    }

    /**
     * Returns the found element(s) according to this constructor setup.
     * If undefined is returned it means the parent cannot be found
     *
     * @returns {HTMLElement[]|undefined}
     */
    select() {
        const target = this.selectParent();
        if (!target) {
            return;
        }
        const baseRes = [...target.querySelectorAll(this.selector)]
            .map((el) => (this.options.shadowRoot ? el.shadowRoot : el))
            .filter((el) => el);
        /** @type {Contains[]} */
        this.childrenContains = [];
        const res = baseRes.filter((el, currentIndex) => {
            let condition =
                (this.options.textContent === undefined ||
                    el.textContent.trim() === this.options.textContent) &&
                (this.options.value === undefined || el.value === this.options.value) &&
                (this.options.scroll === undefined ||
                    (this.options.scroll === "bottom"
                        ? Math.abs(el.scrollHeight - el.clientHeight - el.scrollTop) <= 1
                        : Math.abs(el.scrollTop - this.options.scroll) <= 1));
            if (condition && this.options.text !== undefined) {
                if (
                    el.textContent.trim() !== this.options.text &&
                    [...el.querySelectorAll("*")].every(
                        (el) => el.textContent.trim() !== this.options.text
                    )
                ) {
                    condition = false;
                }
            }
            if (condition && this.options.contains) {
                for (const param of this.options.contains) {
                    const childContains = new Contains(param[0], { ...param[1], target: el });
                    if (
                        !childContains.runOnce(`as child of el ${currentIndex + 1})`, {
                            executeOnSuccess: false,
                        })
                    ) {
                        condition = false;
                    }
                    this.childrenContains.push(childContains);
                }
            }
            if (condition && this.options.visible !== undefined) {
                if (isVisible(el) !== this.options.visible) {
                    condition = false;
                }
            }
            if (condition && this.options.after) {
                const afterContains = new Contains(this.options.after[0], {
                    ...this.options.after[1],
                    target,
                });
                const afterEl = afterContains.runOnce(`as "after"`, {
                    executeOnSuccess: false,
                })?.[0];
                if (
                    !afterEl ||
                    !(el.compareDocumentPosition(afterEl) & Node.DOCUMENT_POSITION_PRECEDING)
                ) {
                    condition = false;
                }
                this.childrenContains.push(afterContains);
            }
            if (condition && this.options.before) {
                const beforeContains = new Contains(this.options.before[0], {
                    ...this.options.before[1],
                    target,
                });
                const beforeEl = beforeContains.runOnce(`as "before"`, {
                    executeOnSuccess: false,
                })?.[0];
                if (
                    !beforeEl ||
                    !(el.compareDocumentPosition(beforeEl) & Node.DOCUMENT_POSITION_FOLLOWING)
                ) {
                    condition = false;
                }
                this.childrenContains.push(beforeContains);
            }
            return condition;
        });
        if (
            this.options.scroll !== undefined &&
            this.scrollListeners &&
            baseRes.length === this.options.count &&
            res.length !== this.options.count
        ) {
            for (const el of baseRes) {
                if (!this.scrollListeners.has(el)) {
                    this.scrollListeners.add(el);
                    el.addEventListener("scroll", this.onScroll);
                }
            }
        }
        return res;
    }

    /**
     * Returns the found element that should act as the target (parent) for the
     * main selector.
     * If undefined is returned it means the parent cannot be found.
     *
     * @returns {HTMLElement|undefined}
     */
    selectParent() {
        if (this.options.parent) {
            this.parentContains = new Contains(this.options.parent[0], {
                ...this.options.parent[1],
                target: this.options.target,
            });
            return this.parentContains.runOnce(`as parent`, { executeOnSuccess: false })?.[0];
        }
        return this.options.target;
    }
}

/**
 * Waits until `count` elements matching the given `selector` are present in
 * `options.target`.
 *
 * @param {string} selector
 * @param {ContainsOptions} [options]
 * @returns {Promise}
 */
__exports.contains = contains; async function contains(selector, options) {
    await new Contains(selector, options).run();
}

const stepState = {
    expectedSteps: null,
    deferred: null,
    timeout: null,
    currentSteps: [],

    clear() {
        clearTimeout(this.timeout);
        this.timeout = null;
        this.deferred = null;
        this.currentSteps = [];
        this.expectedSteps = null;
    },

    check({ crashOnFail = false } = {}) {
        const success =
            this.expectedSteps.length === this.currentSteps.length &&
            this.expectedSteps.every((s, i) => s === this.currentSteps[i]);
        if (!success && !crashOnFail) {
            return;
        }
        QUnit.config.current.assert.verifySteps(this.expectedSteps);
        if (success) {
            this.deferred.resolve();
        } else {
            this.deferred.reject(new Error("Steps do not match."));
        }
        this.clear();
    },
};

if (window.QUnit) {
    QUnit.testStart(() =>
        registerCleanup(() => {
            if (stepState.expectedSteps) {
                stepState.check({ crashOnFail: true });
            } else {
                stepState.clear();
            }
        })
    );
}

/**
 * Indicate the completion of a test step. This step must then be verified by
 * calling `assertSteps`.
 *
 * @param {string} step
 */
__exports.step = step; function step(step) {
    stepState.currentSteps.push(step);
    QUnit.config.current.assert.step(step);
    if (stepState.expectedSteps) {
        stepState.check();
    }
}

/**
 * Wait for the given steps to be executed or for the timeout to be reached.
 *
 * @param {string[]} steps
 */
__exports.assertSteps = assertSteps; function assertSteps(steps) {
    if (stepState.expectedSteps) {
        stepState.check({ crashOnFail: true });
    }
    stepState.expectedSteps = steps;
    stepState.deferred = makeDeferred();
    stepState.timeout = setTimeout(() => stepState.check({ crashOnFail: true }), 2000);
    stepState.check();
    return stepState.deferred;
}

return __exports;
});

odoo.define(`@web/../tests/utils`, ['@web/../tests/legacy/utils'], function (require) {
                        return require('@web/../tests/legacy/utils');
                        });
;

/**********************************************************
*  Filepath: /web/static/tests/tours/user_switch_tour.js  *
*  Lines: 156                                             *
**********************************************************/
odoo.define('@web/../tests/tours/user_switch_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

function logout() {
    return [
        {
            content: "check we're logged in",
            trigger: ".o_user_menu .dropdown-toggle",
            run: "click",
        },
        {
            content: "click the Log out button",
            trigger: ".dropdown-item[data-menu=logout]",
            run: "click",
        },
    ];
}

registry.category("web_tour.tours").add("test_user_switch", {
    url: "/odoo",
    steps: () => [
        ...logout(),
        {
            content: "check if the login input is empty",
            trigger: "input#login:empty",
        },
        {
            content: "check if the password input is empty",
            trigger: "input#password:empty",
        },
        {
            content: "Should contains the user switch button",
            trigger: ".oe_login_form .o_user_switch_btn",
            run: "click",
        },
        {
            content: "Click on Marc Demo on the quick login page",
            trigger:
                ".o_user_switch:not(:has(.list-group-item:nth-child(2))) .list-group-item:contains('Marc Demo')",
            run: "click",
        },
        {
            content: "Check user choice button to back on the quick login page",
            trigger: ".oe_login_form .o_user_switch_btn",
            run: "click",
        },
        {
            content: "Display the login form",
            trigger: ".o_user_switch .fa-user-circle-o",
            run: "click",
        },
        {
            content: "fill the login",
            trigger: "input#login",
            run: "edit admin",
        },
        {
            content: "fill the password",
            trigger: "input#password",
            run: "edit admin",
        },
        {
            content: "click on login button",
            trigger: 'button:contains("Log in")',
            run: "click",
        },
        ...logout(),
        {
            content: "Check if there is Mitchell Admin in user list selection",
            trigger: ".o_user_switch .list-group-item:nth-child(1):contains('Mitchell Admin')",
        },
        {
            content: "Check if there is Marc Demo in user list selection",
            trigger: ".o_user_switch .list-group-item:nth-child(2):contains('Marc Demo')",
        },
        {
            content: "Choice demo",
            trigger: ".o_user_switch .list-group-item:contains('Marc Demo')",
            run: "click",
        },
        {
            content: "check the login for demo",
            trigger: "input#login:value('demo')",
        },
        {
            content: "fill the password",
            trigger: "input#password",
            run: "edit demo",
        },
        {
            content: "Check back button to back on the quick login page",
            trigger: ".oe_login_form .o_user_switch_btn",
            run: "click",
        },
        {
            content: "Check have 2 users",
            trigger: ".o_user_switch .list-group-item:nth-child(2)",
        },
        {
            content: "Click on Mitchell Admin",
            trigger: ".o_user_switch .list-group-item:nth-child(1):contains('Mitchell Admin')",
            run: "click",
        },
        {
            content: "check the login for admin",
            trigger: "input#login:value('admin')",
        },
        {
            content: "fill the password",
            trigger: "input#password",
            run: "edit admin",
        },
        {
            content: "Check back button to back on the quick login page",
            trigger: ".oe_login_form .o_user_switch_btn",
            run: "click",
        },
        {
            content: "Display the login form",
            trigger: ".o_user_switch .fa-user-circle-o",
            run: "click",
        },
        {
            content: "the login form is display",
            trigger: "form.oe_login_form:not(.d-none)",
        },
        {
            content: "check if the login input is empty",
            trigger: "input#login:empty",
        },
        {
            content: "check if the password input is empty",
            trigger: "input#password:empty",
        },
        {
            content: "Back to user switch",
            trigger: ".oe_login_form .o_user_switch_btn",
            run: "click",
        },
        {
            content: "Remove the admin user from page",
            trigger: ".o_user_switch .d-flex:first-child .fa-times",
            run: "click",
        },
        {
            content: "only one user is left on quick login",
            trigger:
                ".o_user_switch:not(:has(.list-group-item:nth-child(2))) .list-group-item:contains('Marc Demo')",
        },
    ],
});

return __exports;
});
;

/********************************************************************
*  Filepath: /mail/static/tests/tours/activity_date_format_tour.js  *
*  Lines: 49                                                        *
********************************************************************/
odoo.define('@mail/../tests/tours/activity_date_format_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("mail_activity_date_format", {
    steps: () => [
        {
            trigger: "button:contains('Activities')",
            run: "click",
        },
        {
            trigger: "input[id*='activity_type_id']",
            run: "click",
        },
        {
            trigger: ".dropdown-item:contains('To-Do')",
            run: "click",
        },
        {
            trigger: "div[name='summary'] input",
            run: "edit Go Party",
        },
        {
            trigger: "button:contains('Schedule')",
            run: "click",
        },
        {
            trigger: ".o-mail-Activity:contains('Go Party')",
            run: "click",
        },
        {
            trigger: ".o-mail-Activity-info i",
            run: "click",
        },
        // Format expected from the server for 9 AM at the first day of 2024 is date_format = "%d/%b/%y", time_format = "%I:%M:%S %p".
        {
            trigger:
                ".o-mail-Activity-details tr:contains('Created') td:contains('01/Jan/24 09:00:00 AM')",
        },
        {
            // Default due date is 5 days after creation date.
            trigger: ".o-mail-Activity-details tr:contains('Due on') td:contains('06/Jan/24')",
        },
    ],
});

return __exports;
});
;

/************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_channel_as_guest_tour.js  *
*  Lines: 30                                                            *
************************************************************************/
odoo.define('@mail/../tests/tours/discuss_channel_as_guest_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("discuss_channel_as_guest_tour.js", {
    steps: () => [
        {
            content: "Channel secret token has been hidden on welcome page",
            trigger: ".o-mail-WelcomePage",
            run() {
                if (!window.location.pathname.startsWith("/discuss/channel")) {
                    console.error("Channel secret token is still present in URL.");
                }
            },
        },
        {
            content: "Click join",
            trigger: "button[title='Join Channel']",
            run: "click",
        },
        {
            content: "Check that we are on channel page",
            trigger: ".o-mail-Thread",
        },
    ],
});

return __exports;
});
;

/***************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_channel_call_public_tour.js  *
*  Lines: 36                                                               *
***************************************************************************/
odoo.define('@mail/../tests/tours/discuss_channel_call_public_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("discuss_channel_call_public_tour.js", {
    steps: () => [
        {
            content: "The call does not start on the welcome page",
            trigger: ".o-mail-WelcomePage",
            async run() {
                await new Promise((r) => setTimeout(r, 250));
                const rtcService = odoo.__WOWL_DEBUG__.root.env.services["discuss.rtc"];
                if (rtcService?.selfSession || rtcService?.state.hasPendingRequest) {
                    console.error("The call should not have started.");
                }
            },
        },
        {
            content: "Click join",
            trigger: "button[title='Join Channel']",
            run: "click",
        },
        {
            content: "Check that the call has started",
            trigger: ".o-discuss-Call",
        },
        {
            content: "Check that current user is in call ('disconnect' button visible)",
            trigger: "button[title='Disconnect']",
        },
    ],
});

return __exports;
});
;

/**********************************************************************
*  Filepath: /mail/static/tests/tours/discuss_channel_public_tour.js  *
*  Lines: 214                                                         *
**********************************************************************/
odoo.define('@mail/../tests/tours/discuss_channel_public_tour', ['@web/core/registry', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { click, contains, inputFiles } = require("@web/../tests/utils");

registry.category("web_tour.tours").add("discuss_channel_public_tour.js", {
    steps: () => [
        {
            trigger: ".o-mail-Discuss",
        },
        {
            content: "Check that we are on channel page",
            trigger: ".o-mail-Thread",
            run() {
                if (!window.location.pathname.startsWith("/discuss/channel")) {
                    console.error("Channel secret token is still present in URL.");
                }
                const errors = odoo.loader.findErrors();
                if (Object.keys(errors).length) {
                    console.error("Couldn't load all JS modules.", errors);
                }
                document.body.classList.add("o_discuss_channel_public_modules_loaded");
                if (
                    document.title !== document.querySelector(".o-mail-Discuss-threadName")?.value
                ) {
                    console.error("Tab title should match conversation name.");
                }
            },
        },
        {
            content: "Wait for all modules loaded check in previous step",
            trigger: ".o_discuss_channel_public_modules_loaded",
        },
        {
            content: "Write something in composer",
            trigger: ".o-mail-Composer-input",
            run: "edit cheese",
        },
        {
            content: "Add a text file in composer",
            trigger: ".o-mail-Composer button[aria-label='Attach files']",
            async run() {
                const text = new File(["hello, world"], "text.txt", { type: "text/plain" });
                await inputFiles(".o-mail-Composer-coreMain .o_input_file", [text]);
            },
        },
        {
            trigger: ".o-mail-AttachmentCard:not(.o-isUploading)", // waiting the attachment to be uploaded
        },
        {
            content: "Check the text attachment is listed",
            trigger: '.o-mail-AttachmentCard[title="text.txt"]',
        },
        {
            content: "Add an image file in composer",
            trigger: ".o-mail-Composer button[aria-label='Attach files']",
            async run() {
                await inputFiles(".o-mail-Composer-coreMain .o_input_file", [
                    new File(
                        [
                            await (
                                await fetch(
                                    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2P4v5ThPwAG7wKklwQ/bwAAAABJRU5ErkJggg=="
                                )
                            ).blob(),
                        ],
                        "image.png",
                        { type: "image/png" }
                    ),
                ]);
            },
        },
        {
            trigger: ".o-mail-AttachmentImage:not(.o-isUploading)",
        },
        {
            content: "Check the image attachment is listed",
            trigger: '.o-mail-AttachmentImage[title="image.png"]',
            async run() {
                const store = odoo.__WOWL_DEBUG__.root.env.services["mail.store"];
                if (store.self.type === "guest") {
                    const src = this.anchor.querySelector("img").src;
                    const token = store.Attachment.get(
                        (src.match("/web/image/([0-9]+)") || []).at(-1)
                    )?.access_token;
                    if (!(token && src.includes(`access_token=${token}`))) {
                        throw new Error("Access token of the attachment isn't correct.");
                    }
                }
            },
        },
        {
            content: "Send message",
            trigger: ".o-mail-Composer-send:enabled",
            run: "click",
        },
        {
            content: "Check message is shown",
            trigger: '.o-mail-Message-body:contains("cheese")',
        },
        {
            content: "Check message contains the attachment",
            trigger: '.o-mail-Message .o-mail-AttachmentCard:contains("text.txt")',
        },
        {
            trigger: ".o-mail-Message-textContent:contains(cheese)",
            run: "hover && click .o-mail-Message [title='Add a Reaction']",
        },
        {
            trigger: ".o-EmojiPicker .o-Emoji:contains('🙂')",
            run: "click",
        },
        {
            content: "Reload page (fetch reactions)",
            trigger: ".o-mail-Message",
            run() {
                location.reload();
            },
        },
        {
            content: "Remove reaction",
            trigger: ".o-mail-MessageReaction:contains('🙂')",
            run: "click",
        },
        {
            content: "Reload page (fetch reactions)",
            trigger: ".o-mail-Message",
            run() {
                location.reload();
            },
        },
        {
            trigger: ".o-mail-Message:not(:has(.o-mail-MessageReaction))",
        },
        {
            content: "Click on more menu",
            trigger: ".o-mail-Message-textContent:contains(cheese)",
            run: "hover && click .o-mail-Message [title='Expand']",
        },
        {
            content: "Click on edit",
            trigger: ".o-mail-Message-moreMenu [title='Edit'], .o-mail-Message [title='Edit']",
            run: "click",
        },
        {
            content: "Edit message",
            trigger: ".o-mail-Message .o-mail-Composer-input",
            run: "edit vegetables",
        },
        {
            content: "Add one more file in composer",
            trigger: ".o-mail-Message button[aria-label='Attach files']",
            async run() {
                const extratxt = new File(["hello 2"], "extra.txt", { type: "text/plain" });
                await inputFiles(".o-mail-Message .o_input_file", [extratxt]);
            },
        },
        {
            trigger: ".o-mail-Message .o-mail-Composer .o-mail-AttachmentCard:not(.o-isUploading)", // waiting the attachment to be uploaded
        },
        {
            content: "Check the earlier provided extra attachment is listed",
            trigger: '.o-mail-Message .o-mail-Composer .o-mail-AttachmentCard[title="extra.txt"]',
        },
        {
            content: "Save edited message",
            trigger: ".o-mail-Message a:contains(save)",
            run: "click",
        },
        {
            content: "Check message is edited",
            trigger: '.o-mail-Message-body:contains("vegetables")',
        },
        {
            content: "Check edited message contains the first attachment",
            trigger: '.o-mail-Message .o-mail-AttachmentCard:contains("text.txt")',
        },
        {
            content: "Check edited message contains the extra attachment",
            trigger: '.o-mail-Message .o-mail-AttachmentCard:contains("extra.txt")',
            async run() {
                await click(".o-mail-AttachmentCard-unlink", {
                    parent: [".o-mail-AttachmentCard", { text: "extra.txt" }],
                });
                await click(".btn", { text: "Ok", parent: [".modal", { text: "Confirmation" }] });
                await contains(".o-mail-AttachmentCard", { text: "extra.txt", count: 0 });
            },
        },
        {
            content: "Open search panel",
            trigger: "button[title='Search Messages']",
            run: "click",
        },
        {
            content: "Search for the attachment name",
            trigger: ".o_searchview_input",
            run: "edit text.txt",
        },
        {
            content: "Trigger the search",
            trigger: "button[aria-label='Search button']",
            run: "click",
        },
        {
            content: "Check that searched message contains the attachment",
            trigger:
                '.o-mail-SearchMessagesPanel .o-mail-Message .o-mail-AttachmentCard:contains("text.txt")',
        },
    ],
});

return __exports;
});
;

/*********************************************************************
*  Filepath: /mail/static/tests/tours/discuss_configuration_tour.js  *
*  Lines: 88                                                         *
*********************************************************************/
odoo.define('@mail/../tests/tours/discuss_configuration_tour', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add("discuss_configuration_tour", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            trigger: '.o_app[data-menu-xmlid="mail.menu_root_discuss"]',
            run: "click",
        },
        {
            trigger: ".o_main_navbar button:contains('Configuration')",
            run: "click",
        },
        {
            trigger: ".dropdown-menu a:contains('Notification')",
            run: "click",
        },
        {
            trigger: ".o-mail-DiscussNotificationSettings label:contains('Mute')",
            run: "click",
        },
        {
            trigger: "button:contains('All Messages')",
            run: "click",
        },
        {
            trigger: "button:contains('Mentions Only')",
            run: "click",
        },
        {
            trigger: "button:contains('Nothing')",
            run: "click",
        },
        {
            trigger: ".modal-header button[aria-label='Close']",
            run: "click",
        },
        {
            trigger: ".o_main_navbar button:contains('Configuration')",
            run: "click",
        },
        {
            trigger: ".dropdown-menu a:contains('Voice & Video')",
            run: "click",
        },
        {
            trigger: "select[name='inputDevice']",
        },
        {
            trigger: "button:contains('Voice Detection')",
            run: "click",
        },
        {
            trigger: "label:contains('Voice detection threshold')",
        },
        {
            trigger: "button:contains('Push to Talk')",
            run: "click",
        },
        {
            trigger: "label:contains('Push-to-talk key')",
        },
        {
            trigger: "label:contains('Delay after releasing push-to-talk')",
        },
        {
            trigger: "input[aria-label='Show video participants only']",
        },
        {
            trigger: "input[aria-label='Blur video background']",
            run: "click",
        },
        {
            trigger: "label:contains('Background blur intensity')",
        },
        {
            trigger: "label:contains('Edge blur intensity')",
        },
    ],
});

return __exports;
});
;

/******************************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_go_back_to_thread_from_breadcrumbs_tour.js  *
*  Lines: 17                                                                              *
******************************************************************************************/
odoo.define('@mail/../tests/tours/discuss_go_back_to_thread_from_breadcrumbs_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("discuss_go_back_to_thread_from_breadcrumbs.js", {
    steps: () => [
        { trigger: ".o-mail-Discuss-threadName[title='Inbox']" },
        { trigger: ".o-mail-DiscussSidebar-item:contains(Starred)", run: "click" },
        { trigger: "button[title='View or join channels']", run: "click" },
        { trigger: ".breadcrumb-item:contains(Starred)", run: "click" },
        { trigger: ".o-mail-Discuss-threadName[title='Starred']" },
    ],
});

return __exports;
});
;

/******************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_sidebar_in_public_page_tour.js  *
*  Lines: 46                                                                  *
******************************************************************************/
odoo.define('@mail/../tests/tours/discuss_sidebar_in_public_page_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("sidebar_in_public_page_tour", {
    steps: () => [
        {
            trigger: ".o-mail-Discuss-header [title='Channel 1']",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 1).o-active",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 2)",
            run: "click",
        },
        {
            trigger: ".o-mail-Discuss-header [title='Channel 2']",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 2).o-active",
            run() {
                history.back();
            },
        },
        {
            trigger: ".o-mail-Discuss-header [title='Channel 1']",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 1).o-active",
            run() {
                history.forward();
            },
        },
        {
            trigger: ".o-mail-Discuss-header [title='Channel 2']",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 2).o-active",
        },
    ],
});

return __exports;
});
;

/**************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_sub_channel_search_tour.js  *
*  Lines: 99                                                              *
**************************************************************************/
odoo.define('@mail/../tests/tours/discuss_sub_channel_search_tour', ['@web/../tests/utils', '@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { contains, scroll } = require("@web/../tests/utils");
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("test_discuss_sub_channel_search", {
    steps: () => [
        {
            trigger: "button[title='Threads']",
            run: "click",
        },
        {
            trigger: ".o-mail-SubChannelList",
            async run() {
                // 30 newest sub channels are loaded initially.
                for (let i = 99; i > 69; i--) {
                    await contains(".o-mail-SubChannelList-thread", {
                        text: `Sub Channel ${i}`,
                    });
                    await contains(".o-mail-SubChannelList-thread", { count: 30 });
                }
            },
        },
        {
            trigger: ".o-mail-ActionPanel:has(.o-mail-SubChannelList) .o_searchview_input",
            run: "edit Sub Channel 10",
        },
        {
            trigger:
                ".o-mail-ActionPanel:has(.o-mail-SubChannelList) button[aria-label='Search button']",
            run: "click",
        },
        {
            trigger: ".o-mail-SubChannelList-thread:contains(Sub Channel 10)",
            async run() {
                await contains(".o-mail-SubChannelList-thread", { count: 1 });
            },
        },
        {
            trigger: ".o_searchview_input",
            run: "clear",
        },
        {
            trigger: ".o-mail-SubChannelList-thread:contains(Sub Channel 99)",
            async run() {
                await contains(".o-mail-SubChannelList-thread", { count: 31 });
                // Already fetched sub channels are shown in addition to the one
                // that was fetched during the search.
                for (let i = 99; i > 69; i--) {
                    await contains(".o-mail-SubChannelList-thread", {
                        text: `Sub Channel ${i}`,
                    });
                }
                await contains(".o-mail-SubChannelList-thread", { text: `Sub Channel 10` });
                // Ensure lazy loading is still working after a search.
                await scroll(".o-mail-ActionPanel:has(.o-mail-SubChannelList)", "bottom");
            },
        },
        {
            trigger: ".o-mail-SubChannelList-thread:contains(Sub Channel 40)",
            async run() {
                await contains(".o-mail-SubChannelList-thread", { count: 61 });
                for (let i = 99; i > 39; i--) {
                    await contains(".o-mail-SubChannelList-thread", {
                        text: `Sub Channel ${i}`,
                    });
                }
                await scroll(".o-mail-ActionPanel:has(.o-mail-SubChannelList)", "bottom");
            },
        },
        {
            trigger: ".o-mail-SubChannelList-thread:contains(Sub Channel 11)",
            async run() {
                await contains(".o-mail-SubChannelList-thread", { count: 90 });
                for (let i = 99; i > 9; i--) {
                    await contains(".o-mail-SubChannelList-thread", {
                        text: `Sub Channel ${i}`,
                    });
                }
                await scroll(".o-mail-ActionPanel:has(.o-mail-SubChannelList)", "bottom");
            },
        },
        {
            trigger: ".o-mail-SubChannelList-thread:contains(Sub Channel 0)",
            async run() {
                await contains(".o-mail-SubChannelList-thread", { count: 100 });
                for (let i = 99; i > 0; i--) {
                    await contains(".o-mail-SubChannelList-thread", {
                        text: `Sub Channel ${i}`,
                    });
                }
            },
        },
    ],
});

return __exports;
});
;

/******************************************************************************
*  Filepath: /mail/static/tests/tours/mail_activity_schedule_from_chatter.js  *
*  Lines: 65                                                                  *
******************************************************************************/
odoo.define('@mail/../tests/tours/mail_activity_schedule_from_chatter', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("mail_activity_schedule_from_chatter", {
    steps: () => [
        {
            trigger: "button:contains('Activities')",
            run: "click",
        },
        {
            trigger: "input[id*='activity_type_id']",
            run: "click",
        },
        {
            trigger: ".dropdown-item:contains('Call')",
            run: "click",
        },
        {
            trigger: "input[id*='activity_type_id']:value('Call')",
        },
        {
            trigger: "button:contains('Schedule')",
        },
        {
            trigger: "input[id*='activity_type_id']",
            run: "click",
        },
        {
            trigger: ".dropdown-item:contains('To-Do')",
            run: "click",
        },
        {
            trigger: "div[name='summary'] input",
            run: "edit Play Mario Party",
        },
        {
            trigger: "button:contains('Schedule')",
            run: "click",
        },
        {
            trigger: ".o-mail-Activity:contains('Play Mario Party')",
            run: "click",
        },
        {
            trigger: "button:contains('Activities')",
            run: "click",
        },
        {
            trigger: "div[name='summary'] input",
            run: "edit Play Mario Kart",
        },
        {
            trigger: "button:contains('Mark as Done')",
            run: "click",
        },
        {
            trigger: ".o-mail-Message:contains('Play Mario Kart')",
        },
    ],
});

return __exports;
});
;

/******************************************************************
*  Filepath: /mail/static/tests/tours/mail_composer_test_tour.js  *
*  Lines: 309                                                     *
******************************************************************/
odoo.define('@mail/../tests/tours/mail_composer_test_tour', ['@web/core/registry', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { contains, dragenterFiles, dropFiles, inputFiles } = require("@web/../tests/utils");

/**
 * This tour depends on data created by python test in charge of launching it.
 * It is not intended to work when launched from interface. It is needed to test
 * an action (action manager) which is not possible to test with QUnit.
 * @see mail/tests/test_mail_composer.py
 */
registry.category("web_tour.tours").add("mail/static/tests/tours/mail_composer_test_tour.js", {
    steps: () => [
        {
            content: "Wait for the chatter to be fully loaded",
            trigger: ".o-mail-Chatter",
            async run() {
                await contains(".o-mail-Message", { count: 1 });
            },
        },
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Write something in composer",
            trigger: ".o-mail-Composer-input",
            run: "edit blahblah @Not && click body",
        },
        {
            content: "Mention a partner",
            trigger: ".o-mail-Composer-suggestion:contains(Not A Demo User)",
            run: "click",
        },
        {
            content: "Add one file in composer",
            trigger: ".o-mail-Composer button[aria-label='Attach files']",
            async run() {
                const files = [new File(["hello, world"], "file1.txt", { type: "text/plain" })];
                await inputFiles(".o-mail-Composer-coreMain .o_input_file", files);
            },
        },
        {
            trigger: ".o-mail-AttachmentCard:not(.o-isUploading)", // waiting the attachment to be uploaded
        },
        {
            content: "Open full composer",
            trigger: "button[aria-label='Full composer']",
            run: "click",
        },
        {
            content: "Check composer keeps open after pushing Escape",
            trigger: ".o_mail_composer_form_view",
            run: "press Escape",
        },
        {
            content: "Check the earlier provided attachment is listed",
            trigger: ".o_field_mail_composer_attachment_list a:contains(file1.txt)",
        },
        {
            content: "Check subject is autofilled",
            trigger: '[name="subject"] input',
            run() {
                const subjectValue = document.querySelector('[name="subject"] input').value;
                if (subjectValue !== "Jane") {
                    console.error(
                        `Full composer should have "Jane" in subject input (actual: ${subjectValue})`
                    );
                }
            },
        },
        {
            content: "Check composer content is kept and contains the user's signature",
            trigger: '.o_field_html[name="body"]',
            run() {
                const bodyContent = document.querySelector(
                    '.o_field_html[name="body"]'
                ).textContent;
                if (!bodyContent.includes("blahblah @Not A Demo User")) {
                    console.error(
                        `Full composer should contain text from small composer ("blahblah @Not A Demo User") in body input (actual: ${bodyContent})`
                    );
                }
                const mentionLink = document.querySelector(
                    '.o_field_html[name="body"] a'
                ).textContent;
                if (!mentionLink.includes("@Not A Demo User")) {
                    console.error(
                        `Full composer should contain mention link from small composer ("@Not A Demo User") in body input)`
                    );
                }
                /** When opening the full composer for the first time, the system
                 * should add the user's signature to the end of the message so
                 * that the user can edit it. After adding the signature to
                 * the editor, the server shouldn't automatically add the
                 * signature to the message (see: Python tests). */
                if ((bodyContent.match(/--\nErnest/g) || []).length !== 1) {
                    console.error("Full composer should contain the user's signature once.");
                }
            },
        },
        {
            content: "Drop a file on the full composer",
            trigger: ".o_mail_composer_form_view",
            async run() {
                const files = [new File(["hi there"], "file2.txt", { type: "text/plain" })];
                await dragenterFiles(".o_mail_composer_form_view .o_form_renderer", files);
                await dropFiles(".o-Dropzone", files);
            }
        },
        {
            content: "Check the attachment is listed",
            trigger: ".o_field_mail_composer_attachment_list a:contains(file2.txt)",
        },
        {
            content: "Click on the mail template selector",
            trigger: ".mail-composer-template-dropdown-btn",
            run: "click",
        },
        {
            content: "Check a template is listed",
            trigger:
                '.mail-composer-template-dropdown.popover .o-dropdown-item:contains("Test template")',
        },
        {
            content: "Send message from full composer",
            trigger: ".o_mail_send",
            run: "click",
        },
        {
            content: "Check message is shown",
            trigger: '.o-mail-Message-body:contains("blahblah @Not A Demo User")',
            run: "click",
        },
        {
            content: "Click on envelope to see recipients of message",
            trigger:
                '.o-mail-Message:has(.o-mail-Message-body:contains("blahblah @Not A Demo User")) .o-mail-Message-notification',
            run: "click",
        },
        {
            content: "Check message has correct recipients",
            trigger: ".o-mail-MessageNotificationPopover:contains('Not A Demo User\nJane')",
        },
        {
            content: "Check message contains the first attachment",
            trigger: '.o-mail-Message .o-mail-AttachmentCard:contains("file1.txt")',
        },
        {
            content: "Check message contains the second attachment",
            trigger: '.o-mail-Message .o-mail-AttachmentCard:contains("file2.txt")',
        },
        // Test the full composer input text is kept on closing
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Open full composer",
            trigger: "button[aria-label='Full composer']",
            run: "click",
        },
        {
            content: "Check that the composer contains the signature",
            trigger: '.o_field_html[name="body"]',
            run() {
                const bodyContent = document.querySelector(
                    '.o_field_html[name="body"]'
                ).textContent;
                /** When opening the full composer, the system should add the
                 * user's signature, as this is a new message and the signature
                 * has not yet been added to it. */
                if ((bodyContent.match(/--\nErnest/g) || []).length !== 1) {
                    console.log("Full composer should contain the user's signature once.");
                }
            }
        },
        {
            content: "Write something in full composer",
            trigger: ".note-editable",
            run: "editor keep the content",
        },
        {
            content: "Close full composer",
            trigger: ".btn-close",
            run: "click",
        },
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Check full composer text is kept",
            trigger: ".o-mail-Composer-input",
            run() {
                if (this.anchor.value !== "keep the content") {
                    console.error(
                        "Composer in chatter should contain full composer text after discarding."
                    );
                }
            },
        },
        {
            content: "Open full composer",
            trigger: "button[aria-label='Full composer']",
            run: "click",
        },
        {
            content: "Check that the composer doesn't add the user's signature twice",
            trigger: ".note-editable",
            run() {
                const bodyContent = document.querySelector(
                    '.o_field_html[name="body"]'
                ).textContent;
                /** When re-opening the full composer, the system shouldn't re-add
                 * the user's signature to the message. As the user deleted the
                 * signature in the previous steps (see: `editor keep the content`),
                 * the editor shouldn't contain any signature. */
                if ((bodyContent.match(/--\nErnest/g) || []).length !== 0) {
                    console.error("The composer should not contain the user's signature.");
                }
            }
        },
        {
            content: "Close full composer",
            trigger: ".btn-close",
            run: "click",
        },
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Send message from chatter",
            trigger: ".o-mail-Composer-send",
            run: "click"
        },
        {
            content: "Check message is shown",
            trigger: '.o-mail-Message-body:contains("keep the content")',
        },
        // Test that the server automatically adds the user's signature to the
        // email when the user didn't open the full composer.
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Write a message",
            trigger: ".o-mail-Composer-input",
            run: "edit hello world",
        },
        {
            content: "Send message from chatter",
            trigger: ".o-mail-Composer-send",
            run: "click"
        },
        {
            content: "Check message is shown",
            trigger: '.o-mail-Message-body:contains("hello world")',
        },
        // Test text input lines are each wrapped in <p> in editor
        // this makes each line editable without impacting the other lines
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Write first line",
            trigger: ".o-mail-Composer-input",
            run: "edit abc",
        },
        {
            content: "Press enter to go to next line",
            trigger: ".o-mail-Composer-input",
            run: "press enter",
        },
        {
            content: "write second line",
            trigger: ".o-mail-Composer-input",
            run: "fill efg",
        },
        {
            content: "Open full composer",
            trigger: "button[aria-label='Full composer']",
            run: "click",
        },
        {
            content: "Check the content of the editor",
            trigger:
                ".o_mail_composer_form_view .odoo-editor-editable > p:contains(abc):not(:contains(efg))",
        },
        {
            content: "Check the content of the editor",
            trigger:
                ".o_mail_composer_form_view .odoo-editor-editable > p:contains(efg):not(:contains(abc))",
        },
    ],
});

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/tests/tours/mail_message_load_order_tour.js  *
*  Lines: 75                                                           *
***********************************************************************/
odoo.define('@mail/../tests/tours/mail_message_load_order_tour', ['@web/core/registry', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { contains, scroll } = require("@web/../tests/utils");

registry.category("web_tour.tours").add("mail_message_load_order_tour", {
    steps: () => [
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(MyTestChannel)",
            run: "click",
        },
        {
            trigger: ".o-mail-Thread .o-mail-Message",
            async run() {
                await contains(".o-mail-Thread .o-mail-Message", { count: 30 });
                await contains(".o-mail-Thread", { scroll: "bottom" });
            },
        },
        {
            trigger: "*[title='Pinned Messages']",
            run: "click",
        },
        {
            content: "Click on invisible jump (should hover card to be visible)",
            trigger: ".o-mail-MessageCard-jump:not(:visible)",
            run: "click",
        },
        {
            // Messages depends on FETCH_LIMIT (currently set to 60) in
            // the thread service. Thus, at first load the message range
            // will be (31 - 60). This trigger ensures the next messages
            // are fetched after jumping to the message.
            trigger:
                ".o-mail-Thread .o-mail-Message:first .o-mail-Message-textContent:not(:contains(31))",
            async run() {
                await contains(".o-mail-Thread .o-mail-Message", { count: 31 });
                await contains(".o-mail-Thread", { scroll: 0 });
                // ensure 1 - 31 are loaded in order: 30 below and the
                // one we're loading messages around.
                const messages = Array.from(
                    document.querySelectorAll(".o-mail-Thread .o-mail-Message-content")
                ).map((el) => el.innerText);
                for (let i = 0; i < 31; i++) {
                    if (messages[i] !== (i + 1).toString()) {
                        throw new Error("Wrong message order after loading around");
                    }
                }
                await scroll(".o-mail-Thread", "bottom");
            },
        },
        {
            // After jumping to the pinned message, the message range
            // was (1 -31): 30 before (but none were found), 30 after
            // and the pinned message itself. This trigger ensures the
            // next messages are fetched after scrolling to the bottom.
            trigger: ".o-mail-Thread .o-mail-Message .o-mail-Message-textContent:contains(17)",
            async run() {
                await contains(".o-mail-Thread .o-mail-Message", { count: 60 });
                // ensure 1 - 60  are loaded in order.
                const messages = Array.from(
                    document.querySelectorAll(".o-mail-Thread .o-mail-Message-content")
                ).map((el) => el.innerText);
                for (let i = 0; i < 60; i++) {
                    if (messages[i] !== (i + 1).toString()) {
                        throw new Error("Wrong message order after loading after");
                    }
                }
            },
        },
    ],
});

return __exports;
});
;

/*********************************************************************************
*  Filepath: /mail/static/tests/tours/mail_template_dynamic_placeholder_tour.js  *
*  Lines: 172                                                                    *
*********************************************************************************/
odoo.define('@mail/../tests/tours/mail_template_dynamic_placeholder_tour', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add("mail_template_dynamic_placeholder_tour", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            content: 'Go into the Setting "app"',
            trigger: '.o_app[data-menu-xmlid="base.menu_administration"]',
            run: "click",
        },
        {
            content: "Open email templates",
            trigger: 'button[name="open_mail_templates"]',
            run: "click",
        },
        {
            content: "Create a new email template",
            trigger: "button.o_list_button_add",
            run: "click",
        },
        {
            content: 'Insert # inside "Subject" input',
            trigger: 'div[name="subject"] input[type="text"]',
            run: "edit(no_model_id #)",
        },
        {
            content: 'Select "Contact" model',
            trigger: 'div[name="model_id"] input[type="text"]',
            run: "edit Contact",
        },
        {
            content: "Wait for the autocomplete RPC",
            trigger: 'div[name="model_id"] .ui-autocomplete:contains("Contact")',
        },
        {
            content: "Click on contact",
            trigger: 'div[name="model_id"] .ui-autocomplete',
            run: async function () {
                const contact = Array.from(
                    document.querySelectorAll(
                        'div[name="model_id"] .ui-autocomplete .dropdown-item'
                    )
                ).find((el) => el.textContent === "Contact");
                await contact.click();
            },
        },
        {
            content: "Wait for the drop down to disappear",
            trigger: 'div[name="model_id"] .o-autocomplete:not(:has(.ui-autocomplete))',
            run: async () => {
                // Ensure the system has registered a correct model value before
                // we try to open the DPH.
                // It seems that the autocomplete validation can be very slow.
                await new Promise((r) => setTimeout(r, 200));
            },
        },
        {
            content: 'Retry insert # inside "Subject" input',
            trigger: 'div[name="subject"] input[type="text"]',
            run: "edit (yes_model_id) && press #",
        },
        {
            content: "Check if the dynamic placeholder popover is opened",
            trigger: "div.o_model_field_selector_popover",
        },
        {
            content: "filter the dph result",
            trigger: "div.o_model_field_selector_popover_search input[type='text']",
            run: "edit name",
        },
        {
            content: "Click on the first entry of the dynamic placeholder",
            trigger: 'div.o_model_field_selector_popover button:contains("Company Name")',
            run: "click",
        },
        {
            content: "Enter a default value",
            trigger:
                'div.o_model_field_selector_popover .o_model_field_selector_default_value_input input[type="text"]',
            run: "edit defValue",
        },
        {
            content: "Click on the insert button",
            trigger: "div.o_model_field_selector_popover button:first-child",
            run: "click",
        },
        {
            content: "Wait for the popover to disappear",
            trigger: "body:not(:has(.o_model_field_selector_popover))",
            run: "click",
        },
        {
            content: "Check if subject value was correctly updated",
            trigger: 'div[name="subject"] input[type="text"]',
            run() {
                const subjectValue = this.anchor.value;
                const correctValue = "yes_model_id {{object.company_name|||defValue}}";
                if (subjectValue !== correctValue) {
                    console.error(
                        `Email template should have "${correctValue}" in subject input (actual: ${subjectValue})`
                    );
                }
            },
        },
        {
            content: "Insert text inside editable",
            trigger: ".note-editable.odoo-editor-editable",
            async run(actions) {
                await actions.editor(`/`);
                document.querySelector(".note-editable").dispatchEvent(
                    new InputEvent("input", {
                        inputType: "insertText",
                        data: "/",
                    })
                );
            },
        },
        {
            content: "Click on the the dynamic placeholder powerBox options",
            trigger: "div.o-we-powerbox .o-we-command:contains(Dynamic Placeholder)",
            run: "click",
        },
        {
            content: "Check if the dynamic placeholder popover is opened",
            trigger: "div.o_model_field_selector_popover",
            run: "click",
        },
        {
            content: "filter the dph result",
            trigger: "div.o_model_field_selector_popover_search input[type='text']",
            run: "edit name",
        },
        {
            content: "Click on the first entry of the dynamic placeholder",
            trigger: 'div.o_model_field_selector_popover button:contains("Company Name")',
            run: "click",
        },
        {
            content: "Enter a default value",
            trigger:
                'div.o_model_field_selector_popover .o_model_field_selector_default_value_input input[type="text"]',
            run: "edit defValue",
        },
        {
            content: "Click on the insert button",
            trigger: "div.o_model_field_selector_popover button:first-child",
            run: "click",
        },
        {
            content: "Ensure the editable contain the dynamic placeholder t tag",
            trigger: `.note-editable.odoo-editor-editable t[t-out="object.company_name"]:contains("defValue")`,
            run: "click",
        },
        {
            content: "Discard form changes",
            trigger: "button.o_form_button_cancel",
            run: "click",
        },
        {
            content: "Wait for the form view to disappear",
            trigger: "body:not(:has(.o_form_sheet))",
        },
    ],
});

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/tests/tours/user_modify_own_profile_tour.js  *
*  Lines: 51                                                           *
***********************************************************************/
odoo.define('@mail/../tests/tours/user_modify_own_profile_tour', ['@web/core/registry', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { contains, insertText } = require("@web/../tests/utils");

/**
 * Verify that a user can modify their own profile information.
 */
registry.category("web_tour.tours").add("mail/static/tests/tours/user_modify_own_profile_tour.js", {
    steps: () => [
        {
            content: "Open user account menu",
            trigger: ".o_user_menu button",
            run: "click",
        },
        {
            content: "Open preferences / profile screen",
            trigger: "[data-menu=settings]",
            run: "click",
        },
        {
            content: "Update the email address",
            trigger: 'div[name="email"] input',
            async run() {
                await insertText("div[name='email'] input", "updatedemail@example.com", {
                    replace: true,
                });
                await contains(".o_form_dirty", { count: 1 });
            },
        },
        {
            trigger: "body.modal-open",
        },
        {
            content: "Save the form",
            trigger: 'button[name="preference_save"]',
            run: "click",
        },
        {
            content: "Wait until the modal is closed",
            trigger: "body:not(.modal-open)",
            async run() {
                await contains(".o_form_dirty", { count: 0 });
            },
        },
    ],
});

return __exports;
});
;

/************************************************************
*  Filepath: /calendar/static/tests/tours/calendar_tour.js  *
*  Lines: 161                                               *
************************************************************/
odoo.define('@calendar/../tests/tours/calendar_tour', ['@odoo/hoot-dom', '@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { waitFor } = require("@odoo/hoot-dom");
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

const todayDate = function () {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const day = String(now.getDate()).padStart(2, "0");

    return `${month}/${day}/${year} 10:00:00`;
};

registry.category("web_tour.tours").add("calendar_appointments_hour_tour", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            trigger: '.o_app[data-menu-xmlid="calendar.mail_menu_calendar"]',
            content: "Open Calendar",
            run: "click",
        },
        {
            trigger: ".o-calendar-button-new",
            content: "Create a new event",
            run: "click",
        },
        {
            trigger: "#name_0",
            content: "Give a name to the new event",
            run: "edit TEST EVENT",
        },
        {
            trigger: "#start_0",
            content: "Give a date to the new event",
            run: `edit ${todayDate()}`,
        },
        {
            trigger: "#duration_0",
            content: "Give a duration to the new event",
            run: "edit 02:00",
        },
        {
            trigger: ".fa-cloud-upload",
            content: "Save the new event",
            run: "click",
        },
        {
            trigger: ".o_back_button",
            content: "Go back to Calendar view",
            run: "click",
        },
        {
            trigger: ".scale_button_selection",
            content: "Click to change calendar view",
            run: "click",
        },
        {
            trigger: '.dropdown-item:contains("Month")',
            content: "Change the calendar view to Month",
            run: "click",
        },
        {
            trigger: ".fc-col-header-cell.fc-day.fc-day-mon",
            content: "Check the day is properly displayed",
            run: "click",
        },
        {
            trigger: '.fc-time:contains("10:00")',
            content: "Check the time is properly displayed",
            run: "click",
        },
        {
            trigger: '.o_event_title:contains("TEST EVENT")',
            content: "Check the event title",
        },
    ],
});

const clickOnTheEvent = {
    content: "Click on the event (focus + waiting)",
    trigger: 'a .fc-event-main:contains("Test Event")',
    async run(actions) {
        await actions.click();
        await new Promise((r) => setTimeout(r, 1000));
        const custom = document.querySelector(".o_cw_custom_highlight");
        if (custom) {
            custom.click();
            await waitFor(".o_cw_popover", { timeout: 8000 });
        }
    },
};

registry.category("web_tour.tours").add("test_calendar_delete_tour", {
    steps: () => [
        {
            content: "Select filter (everybody)",
            trigger: 'div[data-value="all"] input',
            run: "click",
        },
        clickOnTheEvent,
        {
            content: "Delete the event",
            trigger: ".o_cw_popover_delete",
            run: "click",
        },
        {
            content: "Validate the deletion",
            trigger: 'button:contains("Delete")',
            run: "click",
        },
    ],
});

registry.category("web_tour.tours").add("test_calendar_decline_tour", {
    steps: () => [
        clickOnTheEvent,
        {
            content: "Delete the event",
            trigger: ".o_cw_popover_delete",
            run: "click",
        },
        {
            content: "Wait declined status",
            trigger: ".o_attendee_status_declined",
        },
    ],
});

registry.category("web_tour.tours").add("test_calendar_decline_with_everybody_filter_tour", {
    steps: () => [
        {
            content: "Select filter (everybody)",
            trigger: 'div[data-value="all"] input',
            run: "click",
        },
        clickOnTheEvent,
        {
            content: "Delete the event",
            trigger: ".o_cw_popover_delete",
            run: "click",
        },
        {
            content: "Select filter (everybody)",
            trigger: 'div[data-value="all"] input',
            run: "click",
        },
        {
            content: "Wait declined status",
            trigger: ".o_attendee_status_declined",
        },
    ],
});

return __exports;
});
;

/**********************************************************************
*  Filepath: /contacts/static/tests/tours/debug_menu_set_defaults.js  *
*  Lines: 82                                                          *
**********************************************************************/
odoo.define('@contacts/../tests/tours/debug_menu_set_defaults', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

    const { registry } = require("@web/core/registry");
    const { stepUtils } = require("@web_tour/tour_service/tour_utils");

    registry.category("web_tour.tours").add('debug_menu_set_defaults', {
        url: '/odoo?debug=1',
        steps: () => [
            ...stepUtils.goToAppSteps('contacts.menu_contacts', "Open the contacts menu"),
            {
                content: "Create a new contact",
                trigger: '.o-kanban-button-new',
                run: "click",
            },
            {
                content: "Check that Company is checked by default, and not Individual",
                trigger: '.o_field_widget[name="company_type"] input[data-value="company"]:checked',
            },
            {
                content: "Select the individual radio button",
                trigger: '.o_field_widget[name="company_type"] input[data-value="person"]',
                run: "click",
            },
            {
                content: "Open the debug menu",
                trigger: '.o_debug_manager button',
                run: "click",
            },
            {
                content: "Click the Set Defaults menu",
                trigger: '.dropdown-item:contains(Set Default Values)',
                run: "click",
            },
            {
                content: "Choose Company Type = Individual",
                trigger: '#formview_default_fields',
                run: function () {
                    const element_field = document.querySelector('select#formview_default_fields');
                    element_field.value = 'company_type';
                    element_field.dispatchEvent(new Event("change"));
                },
            },
            {
                content: "Check that there are conditions",
                trigger: '#formview_default_conditions',
                run: "click",
            },
            {
                content: "Save the new default",
                trigger: 'footer button:contains(Save default)',
                run: "click",
            },
            {
                content: "Discard the contact creation",
                trigger: 'button.o_form_button_cancel',
                run: "click",
            },
            {
                trigger: '.o_action_manager > .o_kanban_view .o-kanban-button-new',
                run: "click",
            },
            {
                content: "Check that Individual is checked instead of Company",
                trigger: '.o_field_widget[name="company_type"] input[data-value="person"]:checked',
            },
            {
                content: "Discard the contact creation",
                trigger: 'button.o_form_button_cancel',
                run: "click",
            },
            {
                content: "Wait for discard",
                trigger: '.o_control_panel .o-kanban-button-new',
            },
        ]
    });

return __exports;
});
;

/***************************************************
*  Filepath: /portal/static/tests/tours/portal.js  *
*  Lines: 39                                       *
***************************************************/
odoo.define('@portal/../tests/tours/portal', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add('portal_load_homepage', {
    url: '/my',
    steps: () => [
        {
            content: "Check portal is loaded",
            trigger: 'a[href*="/my/account"]:contains("Edit"):first',
            run: "click",
        },
        {
            content: "Load my account details",
            trigger: 'input[value="Joel Willis"]',
            run: "click",
        },
        {
            content: 'type a different phone number',
            trigger: 'input[name="phone"]',
            run: "edit +1 555 666 7788",
        },
        {
            content: "Submit the form",
            trigger: 'button[type=submit]',
            run: "click",
        },
        {
            content: "Check that we are back on the portal",
            trigger: 'a[href*="/my/account"]:contains("Edit"):first',
        }
    ]
});

return __exports;
});
;

/************************************************************
*  Filepath: /portal/static/tests/tours/skip_to_content.js  *
*  Lines: 27                                                *
************************************************************/
odoo.define('@portal/../tests/tours/skip_to_content', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("skip_to_content", {
    url: "/",
    steps: () => [
        {
            content: "Make sure that Skip to Content button is on top of all the links present in header",
            trigger: "a:first-child[class~='o_skip_to_content']",
            run: "click"
        },
        {
            content: "Check if we have been redirected to #wrap",
            trigger: "body",
            run: () => {
                if (!window.location.href.endsWith("#wrap")) {
                    console.error("We should be on #wrap.");
                }
            }
        }
    ]
});

return __exports;
});
;

/**************************************************************
*  Filepath: /crm/static/tests/tours/create_crm_team_tour.js  *
*  Lines: 46                                                  *
**************************************************************/
odoo.define('@crm/../tests/tours/create_crm_team_tour', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add('create_crm_team_tour', {
    url: "/odoo",
    steps: () => [
    ...stepUtils.goToAppSteps('crm.crm_menu_root'),
{
    trigger: 'button[data-menu-xmlid="crm.crm_menu_config"]',
    run: "click",
}, {
    trigger: 'a[data-menu-xmlid="crm.crm_team_config"]',
    run: "click",
}, {
    trigger: 'button.o_list_button_add',
    run: "click",
}, {
    trigger: 'input[id="name_0"]',
    run: "edit My CRM Team",
}, {
    trigger: 'button.o-kanban-button-new',
    run: "click",
}, {
    trigger: 'div.modal-dialog tr:contains("Test Salesman") input.form-check-input',
    run: 'click',
}, {
    trigger: 'div.modal-dialog tr:contains("Test Sales Manager") input.form-check-input',
    run: 'click',
}, {
    trigger: 'div.modal-dialog tr:contains("Test Sales Manager") input.form-check-input:checked',
}, {
    trigger: '.o_list_selection_box:contains(2)',
}, {
    trigger: 'button.o_select_button',
    run: "click",
},
    ...stepUtils.saveForm()
]});

return __exports;
});
;

/*************************************************************************
*  Filepath: /crm/static/tests/tours/crm_email_and_phone_propagation.js  *
*  Lines: 33                                                             *
*************************************************************************/
odoo.define('@crm/../tests/tours/crm_email_and_phone_propagation', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

    const { registry } = require("@web/core/registry");
    const { stepUtils } = require("@web_tour/tour_service/tour_utils");

    registry.category("web_tour.tours").add('crm_email_and_phone_propagation_edit_save', {
        url: '/odoo',
        steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            trigger: '.o_app[data-menu-xmlid="crm.crm_menu_root"]',
            content: 'open crm app',
            run: "click",
        }, {
            trigger: '.o_kanban_record:contains(Test Lead Propagation)',
            content: 'Open the first lead',
            run: 'click',
        },
        {
            trigger: ".o_form_editable .o_field_widget[name=email_from] input",
        },
        {
            trigger: ".o_form_button_save:not(:visible)",
            content: 'Save the lead',
            run: 'click',
        },
    ]});

return __exports;
});
;

/***********************************************************
*  Filepath: /crm/static/tests/tours/crm_forecast_tour.js  *
*  Lines: 93                                               *
***********************************************************/
odoo.define('@crm/../tests/tours/crm_forecast_tour', ['@odoo/hoot-dom', '@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { queryAll } = require("@odoo/hoot-dom");
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");
const today = luxon.DateTime.now();

registry.category("web_tour.tours").add('crm_forecast', {
    url: "/odoo",
    steps: () => [
    stepUtils.showAppsMenuItem(),
    {
        trigger: ".o_app[data-menu-xmlid='crm.crm_menu_root']",
        content: "open crm app",
        run: "click",
    }, {
        trigger: '.dropdown-toggle[data-menu-xmlid="crm.crm_menu_report"]',
        content: 'Open Reporting menu',
        run: 'click',
    }, {
        trigger: '.dropdown-item[data-menu-xmlid="crm.crm_menu_forecast"]',
        content: 'Open Forecast menu',
        run: 'click',
    }, {
        trigger: '.o_column_quick_create:contains(Add next month)',
        content: 'Wait page loading',
    }, {
        trigger: ".o-kanban-button-new",
        content: "click create",
        run: 'click',
    }, {
        trigger: ".o_field_widget[name=name] input",
        content: "complete name",
        run: "edit Test Opportunity 1",
    }, {
        trigger: ".o_field_widget[name=expected_revenue] input",
        content: "complete expected revenue",
        run: "edit 999999",
    }, {
        trigger: "button.o_kanban_edit",
        content: "edit lead",
        run: "click",
    }, {
        trigger: "div[name=date_deadline] input",
        content: "complete expected closing",
        run: `edit ${today.toFormat("MM/dd/yyyy")}`,
    }, {
        trigger: "div[name=date_deadline] input",
        content: "click to make the datepicker disappear",
        run: "click"
    }, {
        trigger: '.o_back_button',
        content: 'navigate back to the kanban view',
        tooltipPosition: "bottom",
        run: "click"
    }, {
        trigger: ".o_kanban_record:contains('Test Opportunity 1')",
        content: "move to the next month",
        async run(helpers) {
            const undefined_groups = queryAll('.o_column_title:contains("None")').length;
            await helpers.drag_and_drop(`.o_opportunity_kanban .o_kanban_group:eq(${1 + undefined_groups})`);
        },
    }, {
        trigger: ".o_kanban_record:contains('Test Opportunity 1')",
        content: "edit lead",
        run: "click"
    }, {
        trigger: ".o_field_widget[name=date_deadline] input",
        content: "complete expected closing",
        run: `edit ${today.plus({ months: 5 }).startOf("month").minus({ days: 1 }).toFormat("MM/dd/yyyy")} && press Escape`,
    }, {
        trigger: ".o_field_widget[name=probability] input",
        content: "max out probability",
        run: "edit 100",
    }, {
        trigger: '.o_back_button',
        content: 'navigate back to the kanban view',
        tooltipPosition: "bottom",
        run: "click"
    }, {
        trigger: '.o_kanban_add_column',
        content: "add next month",
        run: "click"
    }, {
        trigger: ".o_kanban_record:contains('Test Opportunity 1'):contains('Won')",
        content: "assert that the opportunity has the Won banner",
    }
]});

return __exports;
});
;

/********************************************************
*  Filepath: /crm/static/tests/tours/crm_rainbowman.js  *
*  Lines: 127                                           *
********************************************************/
odoo.define('@crm/../tests/tours/crm_rainbowman', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add("crm_rainbowman", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            trigger: ".o_app[data-menu-xmlid='crm.crm_menu_root']",
            content: "open crm app",
            run: "click",
        },
        {
            trigger: ".o-kanban-button-new",
            content: "click create",
            run: "click",
        },
        {
            trigger: ".o_field_widget[name=name] input",
            content: "complete name",
            run: "edit Test Lead 1",
        },
        {
            trigger: ".o_field_widget[name=expected_revenue] input",
            content: "complete expected revenue",
            run: "edit 999999997",
        },
        {
            trigger: "button.o_kanban_add",
            content: "create lead",
            run: "click",
        },
        {
            trigger: ".o_kanban_record:contains('Test Lead 1')",
            content: "move to won stage",
            run: "drag_and_drop (.o_opportunity_kanban .o_kanban_group:eq(3))",
        },
        {
            trigger: ".o_reward_rainbow",
        },
        {
            // This step and the following simulates the fact that after drag and drop,
            // from the previous steps, a click event is triggered on the window element,
            // which closes the currently shown .o_kanban_quick_create.
            trigger: ".o_kanban_renderer",
            run: "click",
        },
        {
            trigger: ".o_kanban_renderer:not(:has(.o_kanban_quick_create))",
        },
        {
            trigger: ".o-kanban-button-new",
            content: "create second lead",
            run: "click",
        },
        {
            trigger: ".o_field_widget[name=name] input",
            content: "complete name",
            run: "edit Test Lead 2",
        },
        {
            trigger: ".o_field_widget[name=expected_revenue] input",
            content: "complete expected revenue",
            run: "edit 999999998",
        },
        {
            trigger: "button.o_kanban_add",
            content: "create lead",
            run: "click",
        },
        {
            trigger: ".o_kanban_record:contains('Test Lead 2')",
        },
        {
            // move first test back to new stage to be able to test rainbowman a second time
            trigger: ".o_kanban_record:contains('Test Lead 1')",
            content: "move back to new stage",
            run: "drag_and_drop .o_opportunity_kanban .o_kanban_group:eq(0) ",
        },
        {
            trigger: ".o_kanban_record:contains('Test Lead 2')",
            content: "click on second lead",
            run: "click",
        },
        {
            trigger: ".o_statusbar_status button[data-value='4']",
            content: "move lead to won stage",
            run: "click",
        },
        {
            content: "wait for save completion",
            trigger: ".o_form_readonly, .o_form_saved",
        },
        {
            trigger: ".o_reward_rainbow",
        },
        {
            trigger: ".o_statusbar_status button[data-value='1']",
            content: "move lead to previous stage & rainbowman appears",
            run: "click",
        },
        {
            trigger: "button[name=action_set_won_rainbowman]",
            content: "click button mark won",
            run: "click",
        },
        {
            content: "wait for save completion",
            trigger: ".o_form_readonly, .o_form_saved",
        },
        {
            trigger: ".o_reward_rainbow",
        },
        {
            trigger: ".o_menu_brand",
            content: "last rainbowman appears",
        },
    ],
});

return __exports;
});
;

/*****************************************************************
*  Filepath: /project/static/tests/tours/personal_stage_tour.js  *
*  Lines: 86                                                     *
*****************************************************************/
odoo.define('@project/../tests/tours/personal_stage_tour', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add('personal_stage_tour', {
    url: '/odoo',
    steps: () => [stepUtils.showAppsMenuItem(), {
    trigger: '.o_app[data-menu-xmlid="project.menu_main_pm"]',
    run: "click",
}, {
    content: "Open Pig Project",
    trigger: '.o_kanban_record:contains("Pig")',
    run: "click",
}, {
    // Default is grouped by stage, user should not be able to create/edit a column
    content: "Check that there is no create column",
    trigger: "body:not(.o_column_quick_create)",
}, {
    content: "Check that there is no create column",
    trigger: "body:not(.o_column_edit)",
}, {
    content: "Check that there is no create column",
    trigger: "body:not(.o_column_delete)",
}, {
    content: "Go to tasks",
    trigger: 'button[data-menu-xmlid="project.menu_project_management"]',
    run: "click",
},{
    content: "Go to my tasks", // My tasks is grouped by personal stage by default
    trigger: 'a[data-menu-xmlid="project.menu_project_management_my_tasks"]',
    run: "click",
}, {
    content: "Check that we can create a new stage",
    trigger: '.o_column_quick_create .o_quick_create_folded',
    run: "click",
}, {
    content: "Create a new personal stage",
    trigger: 'input.form-control',
    run: "edit Never",
}, {
    content: "Confirm create",
    trigger: '.o_kanban_add',
    run: "click",
}, {
    content: "Check that column exists && Open column edit dropdown",
    trigger: ".o_kanban_header:contains(Never)",
    run: "hover && click .o_kanban_header:contains(Never) .dropdown-toggle",
}, {
    content: "Try editing inbox",
    trigger: ".dropdown-item.o_column_edit",
    run: "click",
}, {
    content: "Change title",
    trigger: 'div.o_field_char[name="name"] input',
    run: "edit ((Todo))",
}, {
    content: "Save changes",
    trigger: '.btn-primary:contains("Save")',
    run: "click",
}, {
    content: "Check that column was updated",
    trigger: '.o_kanban_header:contains("Todo")',
    run: "click",
}, {
    content: "Create a personal task from the quick create form",
    trigger: '.o-kanban-button-new',
    run: "click",
}, {
    content: "Create a new personal task",
    trigger: 'input.o_input:not(.o_searchview_input)',
    run: "edit New Test Task",
}, {
    content: "Confirm create",
    trigger: '.o_kanban_add',
    run: "click",
}, {
    content: "Check that task exists",
    trigger: '.o_kanban_record:contains("New Test Task")',
}]});

return __exports;
});
;

/*************************************************************************
*  Filepath: /project/static/tests/tours/project_burndown_chart_tour.js  *
*  Lines: 96                                                             *
*************************************************************************/
odoo.define('@project/../tests/tours/project_burndown_chart_tour', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add('burndown_chart_tour', {
    url: '/odoo',
    steps: () => [stepUtils.showAppsMenuItem(), {
    trigger: '.o_app[data-menu-xmlid="project.menu_main_pm"]',
    run: "click",
}, {
    content: 'Open "Burndown Chart Test" project menu',
            trigger: ".o_kanban_record:contains(Burndown Chart Test)",
    run: `hover && click .o_kanban_record:contains(Burndown Chart Test) .o_dropdown_kanban .dropdown-toggle`,
}, {
    content: `Open "Burndown Chart Test" project's "Burndown Chart" view`,
    trigger: '.o_kanban_manage_reporting div[role="menuitem"] a:contains("Burndown Chart")',
    run: "click",
},
{
    trigger: ".o_graph_renderer",
},
{
    content: 'The sort buttons are not rendered',
    trigger: '.o_graph_renderer:not(:has(.btn-group[role=toolbar][aria-label="Sort graph"]))',
    run: "click",
}, {
    content: 'Remove the project search "Burndown Chart Test"',
    trigger: ".o_searchview_facet:contains(Burndown Chart Test)",
    run: "hover && click .o_facet_remove",
}, {
    content: 'Search Burndown Chart',
    trigger: 'input.o_searchview_input',
    run: `edit Burndown`,
}, {
    content: 'Validate search',
    trigger: '.o_searchview_autocomplete .o_menu_item:contains("Project")',
    run: "click",
}, {
    content: 'Remove the group by "Date: Month > Stage"',
    trigger: '.o_searchview_facet:contains("Stage") .o_facet_remove',
    run: "click",
}, {
    content: 'A "The Burndown Chart must be grouped by Date and Stage" notification is shown when trying to remove the group by "Date: Month > Stage"',
    trigger: '.o_notification_manager .o_notification:contains("The report should be grouped either by ") button.o_notification_close',
    run: "click",
}, {
    content: 'Open the search panel menu',
    trigger: '.o_control_panel .o_searchview_dropdown_toggler',
    run: "click",
}, {
    content: 'The Stage group menu item is visible',
    trigger: '.o_group_by_menu .o_menu_item:contains("Stage")',
    run: "click",
}, {
    content: 'Open the Date group by sub menu',
    trigger: '.o_group_by_menu button.o_menu_item:contains("Date")',
    run: "click",
}, {
    content: 'Click on the selected Date sub menu',
    trigger: '.o_group_by_menu button.o_menu_item:contains("Date") + * .dropdown-item.selected',
    run: "click",
}, {
    content: 'A "The Burndown Chart must be grouped by Date" notification is shown when trying to remove the group by "Date: Month > Stage"',
    trigger: '.o_notification_manager .o_notification:contains("The Burndown Chart must be grouped by Date") button.o_notification_close',
    run: "click",
}, {
    content: 'Open the search panel menu',
    trigger: '.o_control_panel .o_searchview_dropdown_toggler',
    run: "click",
}, {
    content: 'Open the Date filter sub menu',
    trigger: '.o_filter_menu button.o_menu_item:contains("Date")',
    run: "click",
}, {
    content: 'Click on the first Date filter sub menu',
    trigger: '.o_filter_menu .o_menu_item:contains("Date") + * .dropdown-item:first-child',
    run: "click",
}, {
    content: 'Close the Date filter menu',
    trigger: '.o_graph_renderer',
    run: "click",
}, {
    content: 'Open the search panel menu',
    trigger: '.o_control_panel .o_searchview_dropdown_toggler',
    run: "click",
}, {
    content: 'The comparison menu is not rendered',
    trigger: ':not(:has(.o_comparison_menu))',
}]});

return __exports;
});
;

/******************************************************************
*  Filepath: /project/static/tests/tours/project_sharing_tour.js  *
*  Lines: 214                                                     *
******************************************************************/
odoo.define('@project/../tests/tours/project_sharing_tour', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

const projectSharingSteps = [...stepUtils.goToAppSteps("project.menu_main_pm", 'Go to the Project App.'), {
    trigger: ".o_kanban_record:contains(Project Sharing)",
    content: 'Open the project dropdown.',
    run: "hover && click .o_kanban_record:contains(Project Sharing) .o_dropdown_kanban .dropdown-toggle",
}, {
    trigger: '.dropdown-menu a:contains("Share")',
    content: 'Start editing the project.',
    run: "click",
}, {
    trigger: '.modal div[name="collaborator_ids"] .o_field_x2many_list_row_add > a',
    content: 'Add a collaborator to the project.',
    run: "click",
}, {
    trigger: '.modal div[name="collaborator_ids"] div[name="partner_id"] input',
    content: 'Select the user portal as collaborator to the "Project Sharing" project.',
    run: "edit Georges",
}, {
    trigger: '.ui-autocomplete a.dropdown-item:contains("Georges")',
    run: "click",
}, {
    trigger: '.modal div[name="collaborator_ids"] div[name="access_mode"] select',
    content: 'Select "Edit" as Access mode in the "Share Project" wizard.',
    run: 'select "edit"',
}, {
    trigger: '.modal footer > button[name="action_share_record"]',
    content: 'Confirm the project sharing with this portal user.',
    run: "click",
},
{
    trigger: "body:not(:has(.modal))",
},
{
    trigger: '.o_web_client',
    content: 'Go to project portal view to select the "Project Sharing" project',
    run: function () {
        window.location.href = window.location.origin + '/my/projects';
    },
}, {
    id: 'project_sharing_feature',
    trigger: 'table > tbody > tr a:has(span:contains(Project Sharing))',
    content: 'Select "Project Sharing" project to go to project sharing feature for this project.',
    run: "click",
}, {
    trigger: ':iframe .o_project_sharing',
    content: 'Wait the project sharing feature be loaded',
}, {
    trigger: ':iframe button.o-kanban-button-new',
    content: 'Click "Create" button',
    run: 'click',
}, {
    trigger: ':iframe .o_kanban_quick_create .o_field_widget[name="name"] input',
    content: 'Create Task',
    run: "edit Test Create Task",
}, {
    content: "Check that task stages cannot be drag and dropped",
    trigger: ':iframe .o_kanban_group:not(.o_group_draggable)',
}, {
    trigger: ':iframe .o_kanban_quick_create .o_kanban_edit',
    content: 'Go to the form view of this new task',
    run: "click",
}, {
    trigger: ':iframe div[name="stage_id"] div.o_statusbar_status button[aria-checked="false"]:contains(Done)',
    content: 'Change the stage of the task.',
    run: "click",
}, {
    trigger: ':iframe .o-mail-Composer-input',
    content: 'Write a message in the chatter of the task',
    run: "edit I create a new task for testing purpose.",
}, {
    trigger: ':iframe .o-mail-Composer-send:enabled',
    content: 'Send the message',
    run: "click",
}, {
    trigger: ':iframe ol.breadcrumb > li.o_back_button > a:contains(Project Sharing)',
    content: 'Go back to the kanban view',
    run: "click",
}, {
    trigger: ':iframe .o_searchview_dropdown_toggler',
    content: 'open the search panel menu',
    run: "click",
}, {
    trigger: ':iframe .o_filter_menu .dropdown-item:first-child',
    content: 'click on the first item in the filter menu',
    run: "click",
}, {
    trigger: ':iframe .o_group_by_menu .dropdown-item:first-child',
    content: 'click on the first item in the group by menu',
    run: "click",
}, {
    trigger: ':iframe .o_favorite_menu .o_add_favorite',
    content: 'open accordion "save current search" in favorite menu',
    run: "click",
}, {
    trigger: ':iframe .o_favorite_menu .o_accordion_values .o_save_favorite',
    content: 'click to "save" button in favorite menu',
    run: "click",
}, {
    trigger: ':iframe .o_filter_menu .dropdown-item:first-child',
    content: 'click on the first item in the filter menu',
    run: "click",
}, {
    trigger: ':iframe .o_group_by_menu .dropdown-item:first-child',
    content: 'click on the first item in the group by menu',
    run: "click",
}, {
    trigger: ':iframe .o_favorite_menu .o_accordion_values .o_save_favorite',
    content: 'click to "save" button in favorite menu',
    run: "click",
}, {
    trigger: ':iframe button.o_switch_view.o_list',
    content: 'Go to the list view',
    run: "click",
}, {
    trigger: ':iframe .o_list_view',
}, {
    trigger: ':iframe .o_optional_columns_dropdown_toggle',
    run: "click",
}, {
    trigger: ':iframe .dropdown-item:contains("Milestone")',
}, {
    trigger: ':iframe .o_list_view',
    content: 'Check the list view',
}];

registry.category("web_tour.tours").add('project_sharing_tour', {
    url: '/odoo',
    steps: () => {
        return projectSharingSteps;
    }
});

registry.category("web_tour.tours").add("portal_project_sharing_tour", {
    url: "/my/projects",
    steps: () => {
        // The begining of the project sharing feature
        const projectSharingStepIndex = projectSharingSteps.findIndex(s => s?.id === 'project_sharing_feature');
        return projectSharingSteps.slice(projectSharingStepIndex, projectSharingSteps.length);
    }
});

registry.category("web_tour.tours").add("project_sharing_with_blocked_task_tour", {
    url: "/my/projects",
    steps: () => [{
        trigger: 'table > tbody > tr a:has(span:contains("Project Sharing"))',
        content: 'Click on the portal project.',
        run: "click",
    }, {
        trigger: ':iframe article.o_kanban_record',
        content: 'Click on the task',
        run: "click",
    }, {
        trigger: ':iframe a:contains("Blocked By")',
        content: 'Go to the Block by task tab',
        run: "click",
    }, {
        trigger: ':iframe i:contains("This task is currently blocked by")',
        content: 'Check that the blocked task is not visible',
    },
]});

registry.category("web_tour.tours").add("portal_project_sharing_tour_with_disallowed_milestones", {
    url: "/my/projects",
    steps: () => [
        {
            id: "project_sharing_feature",
            trigger: "table > tbody > tr a:has(span:contains(Project Sharing))",
            content:
                'Select "Project Sharing" project to go to project sharing feature for this project.',
            run: "click",
        },
        {
            trigger: ":iframe .o_project_sharing",
            content: "Wait the project sharing feature be loaded",
        },
        {
            trigger: ":iframe button.o_switch_view.o_list",
            content: "Go to the list view",
            run: "click",
        },
        {
            trigger: ":iframe .o_list_view",
        },
        {
            trigger: ":iframe .o_optional_columns_dropdown_toggle",
            run: "click",
        },
        {
            trigger: ":iframe .dropdown-item",
        },
        {
            trigger: ":iframe .dropdown-menu",
            run: function () {
                const optionalFields = Array.from(
                    this.anchor.ownerDocument.querySelectorAll(".dropdown-item")
                ).map((e) => e.textContent);

                if (optionalFields.includes("Milestone")) {
                    throw new Error(
                        "the Milestone field should be absent as allow_milestones is set to False"
                    );
                }
            },
        },
    ],
});

return __exports;
});
;

/****************************************************************************
*  Filepath: /project/static/tests/tours/project_tags_filter_tour_tests.js  *
*  Lines: 73                                                                *
****************************************************************************/
odoo.define('@project/../tests/tours/project_tags_filter_tour_tests', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

function changeFilter(filterName) {
    return [
        {
            trigger: ".o_control_panel_actions .o_searchview_dropdown_toggler",
            content: "open searchview menu",
            run: "click",
        },
        {
            trigger: `.o_favorite_menu .dropdown-item span:contains("${filterName}")`,
            run: "click",
        },
        {
            trigger: ".o_control_panel_actions .o_searchview_dropdown_toggler",
            content: "close searchview menu",
            run: "click",
        },
    ];
}

registry.category("web_tour.tours").add("project_tags_filter_tour", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            trigger: '.o_app[data-menu-xmlid="project.menu_main_pm"]',
            run: "click",
        },
        ...changeFilter("Corkscrew tail tag filter"),
        {
            trigger:
                '.o_kanban_group:has(.o_kanban_header:has(span:contains("goat"))):not(:has(.o_kanban_record))',
            content: "check that the corkscrew tail filter has taken effect",
        },
        {
            trigger:
                '.o_kanban_group:has(.o_kanban_header:has(span:contains("pig"))) .o_kanban_record:has(span:contains("Pigs"))',
            content: "check that the corkscrew tail filter has taken effect",
        },
        ...changeFilter("horned tag filter"),
        {
            trigger:
                '.o_kanban_group:has(.o_kanban_header:has(span:contains("pig"))):not(:has(.o_kanban_record))',
            content: "check that the horned filter has taken effect",
        },
        {
            trigger:
                '.o_kanban_group:has(.o_kanban_header:has(span:contains("goat"))) .o_kanban_record:has(span:contains("Goats"))',
            content: "check that the horned filter has taken effect",
        },
        ...changeFilter("4 Legged tag filter"),
        {
            trigger:
                '.o_kanban_group:has(.o_kanban_header:has(span:contains("pig"))) .o_kanban_record:has(span:contains("Pigs"))',
            content: "check that the 4 legged filter has taken effect",
        },
        {
            trigger:
                '.o_kanban_group:has(.o_kanban_header:has(span:contains("goat"))) .o_kanban_record:has(span:contains("Goats"))',
            content: "check that the 4 legged filter has taken effect",
        },
    ],
});

return __exports;
});
;

/******************************************************************
*  Filepath: /project/static/tests/tours/project_task_history.js  *
*  Lines: 196                                                     *
******************************************************************/
odoo.define('@project/../tests/tours/project_task_history', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/**
 * Project Task history tour.
 * Features tested:
 * - Create / edit a task description and ensure revisions are created on write
 * - Open the history dialog and check that the revisions are correctly shown
 * - Select a revision and check that the content / comparison are correct
 * - Click the restore button and check that the content is correctly restored
 */

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

const baseDescriptionContent = "Test project task history version";
const descriptionField = "div.note-editable.odoo-editor-editable p";
function changeDescriptionContentAndSave(newContent) {
    const newText = `${baseDescriptionContent} ${newContent}`;
    return [ {
        // force focus on editable so editor will create initial p (if not yet done)
        trigger: "div.note-editable.odoo-editor-editable",
        run: "click",
    }, {
        trigger: descriptionField,
        run: async function(actions) {
            const textTriggerElement = this.anchor.querySelector(descriptionField);
            await actions.editor(newText, textTriggerElement);
            await new Promise((r) => setTimeout(r, 300));
        },
    }, {
        trigger: "button.o_form_button_save",
        run: "click",
    }];
}

registry.category("web_tour.tours").add("project_task_history_tour", {
    url: "/odoo",
    steps: () => [stepUtils.showAppsMenuItem(), {
        content: "Open the project app",
        trigger: ".o_app[data-menu-xmlid='project.menu_main_pm']",
        run: "click",
    },
    {
        content: "Open Test History Project",
        trigger: ".o_kanban_view .o_kanban_record:contains(Test History Project)",
        run: "click",
    },
    {
        content: "Open Test History Task",
        trigger: ".o_kanban_view .o_kanban_record:contains(Test History Task)",
        run: "click",
    },
        // edit the description content 3 times and save after each edit
        ...changeDescriptionContentAndSave("0"),
        ...changeDescriptionContentAndSave("1"),
        ...changeDescriptionContentAndSave("2"),
        ...changeDescriptionContentAndSave("3"),
    {
        content: "Go back to kanban view of tasks. this step is added because it takes some time to save the changes, so it's a sort of timeout to wait a bit for the save",
        trigger: ".o_back_button a",
        run: "click",
    },
    {
        content: "Open Test History Task",
        trigger: ".o_kanban_view .o_kanban_record:contains(Test History Task)",
        run: "click",
    },
    {
        content: "Open History Dialog",
        trigger: ".o_form_view .o_cp_action_menus i.fa-cog",
        run: "click",
    },
    {
        trigger: ".dropdown-menu",
    },
    {
        content: "Open History Dialog",
        trigger: ".o_menu_item i.fa-history",
        run: "click",
    }, {
        content: "Verify that 4 revisions are displayed (default empty description after the creation of the task + 3 edits)",
        trigger: ".modal .html-history-dialog .revision-list .btn",
        run: function () {
            const items = document.querySelectorAll(".revision-list .btn");
            if (items.length !== 4) {
                throw new Error('Expect 4 Revisions in the history dialog, got ' + items.length);
            }
        },
    }, {
        content: "Verify that the active revision (revision 4) is related to the third edit",
        trigger: `.modal .history-container .tab-pane:contains("${baseDescriptionContent} 2")`,
        run: "click",
    }, {
        content: "Go to the third revision related to the second edit",
        trigger: ".modal .html-history-dialog .revision-list .btn:nth-child(2)",
        run: "click",
    }, {
        content: "Verify that the active revision is the one clicked in the previous step",
        trigger: `.modal .history-container .tab-pane:contains("${baseDescriptionContent} 1")`,
        run: "click",
    }, {
        content: "Go to comparison tab",
        trigger: ".modal .history-container .nav-item:contains(Comparison) a",
        run: "click",
    }, {
        content: "Verify comparaison text",
        trigger: ".modal .history-container .tab-pane",
        run: function () {
            const comparaisonHtml = this.anchor.innerHTML;
            const correctHtml = `<added>${baseDescriptionContent} 1</added><removed>${baseDescriptionContent} 3</removed>`;
            if (!comparaisonHtml.includes(correctHtml)) {
                console.error(`Expect comparison to be ${correctHtml}, got ${comparaisonHtml}`);
            }
        },
    }, {
        content: "Click on Restore History btn to get back to the selected revision in the previous step",
        trigger: ".modal button.btn-primary:contains(/^Restore history$/)",
        run: "click",
    }, {
        content: "Verify the confirmation dialog is opened",
        trigger: ".modal button.btn-primary:contains(/^Restore$/)",
        run: "click",
    }, {
        content: "Verify that the description contains the right text after the restore",
        trigger: descriptionField,
        run: function () {
            const p = this.anchor?.innerText;
            const expected = `${baseDescriptionContent} 1`;
            if (p !== expected) {
                throw new Error(`Expect description to be ${expected}, got ${p}`);
            }
        }
    }, {
        content: "Go back to projects view.",
        trigger: 'a[data-menu-xmlid="project.menu_projects"]',
        run: "click",
    }, {
        trigger: ".o_kanban_view",
    }, {
        content: "Open Test History Project Without Tasks",
        trigger: ".o_kanban_view .o_kanban_record:contains(Without tasks project)",
        run: "click",
    }, {
        trigger: ".o_kanban_project_tasks",
    }, {
        content: "Switch to list view",
        trigger: ".o_switch_view.o_list",
        run: "click",
    }, {
        content: "Create a new task.",
        trigger: '.o_list_button_add',
        run: "click",
    }, {
        trigger: ".o_form_view",
    }, {
        trigger: 'div[name="name"] .o_input',
        content: 'Set task name',
        run: 'edit New task',
    },
    {
        trigger: "button.o_form_button_save",
        run: "click",
    },
        ...changeDescriptionContentAndSave("0"),
        ...changeDescriptionContentAndSave("1"),
        ...changeDescriptionContentAndSave("2"),
        ...changeDescriptionContentAndSave("3"),
    {
        trigger: ".o_form_view",
    }, {
        content: "Open History Dialog",
        trigger: ".o_cp_action_menus i.fa-cog",
        run: "click",
    }, {
        trigger: ".dropdown-menu",
    }, {
        content: "Open History Dialog",
        trigger: ".o_menu_item i.fa-history",
        run: "click",
    }, {
        content: "Close History Dialog",
        trigger: ".modal-header .btn-close",
        run: "click",
    }, {
        content: "Go back to projects view. this step is added because Tour can't be finished with an open form view in edition mode.",
        trigger: 'a[data-menu-xmlid="project.menu_projects"]',
        run: "click",
    }, {
        content: "Verify that we are on kanban view",
        trigger: 'button.o_switch_view.o_kanban.active',
    }
]});

return __exports;
});
;

/**********************************************************
*  Filepath: /project/static/tests/tours/project_tour.js  *
*  Lines: 162                                             *
**********************************************************/
odoo.define('@project/../tests/tours/project_tour', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add('project_test_tour', {
    url: '/odoo',
    steps: () => [
    stepUtils.showAppsMenuItem(), {
        trigger: '.o_app[data-menu-xmlid="project.menu_main_pm"]',
        run: "click",
    },
    {
        trigger: '.o_project_kanban',
    },
    {
        trigger: '.o-kanban-button-new',
        run: "click",
    }, {
        trigger: '.o_project_name input',
        run: 'edit New Project',
        id: 'project_creation',
    }, {
        trigger: '.o_open_tasks',
        run: "click .modal:visible .btn.btn-primary",
    }, {
        trigger: ".o_kanban_project_tasks .o_column_quick_create .input-group input",
        run: "edit New",
    }, {
        isActive: ["auto"],
        trigger: ".o_kanban_project_tasks .o_column_quick_create .o_kanban_add",
        run: "click",
    },
    {
        trigger: ".o_kanban_group",
    },
    {
        trigger: ".o_kanban_project_tasks .o_column_quick_create .input-group input",
        run: "edit Done",
    }, {
        isActive: ["auto"],
        trigger: ".o_kanban_project_tasks .o_column_quick_create .o_kanban_add",
        run: "click",
    },
    {
        trigger: ".o_kanban_group:eq(0)",
    },
    {
        trigger: '.o-kanban-button-new',
        run: "click",
    },
    {
        trigger: ".o_kanban_project_tasks",
    },
    {
        trigger: '.o_kanban_quick_create div.o_field_char[name=display_name] input',
        run: "edit New task",
    }, {
        trigger: '.o_kanban_quick_create .o_kanban_add',
        run: "click",
    }, {
        trigger: '.o_kanban_record span:contains("New task")',
        run: "click",
    }, {
        trigger: 'a[name="sub_tasks_page"]',
        content: 'Open sub-tasks notebook section',
        run: 'click',
    }, {
        trigger: '.o_field_subtasks_one2many .o_list_renderer a[role="button"]',
        content: 'Add a subtask',
        run: 'click',
    }, {
        trigger: '.o_field_subtasks_one2many div[name="name"] input',
        content: 'Set subtask name',
        run: "edit new subtask",
    }, {
        trigger: ".o_breadcrumb .o_back_button",
        content: 'Go back to kanban view',
        tooltipPosition: "right",
        run: "click",
    }, {
        trigger: ".o_kanban_record .o_widget_subtask_counter .subtask_list_button",
        content: 'open sub-tasks from kanban card',
        run: "click",
    },
    {
        trigger: ".o_widget_subtask_kanban_list .subtask_list",
    },
    {
        trigger: ".o_kanban_record .o_widget_subtask_kanban_list .subtask_create",
        content: 'Create a new sub-task',
        run: "click",
    },
    {
        trigger: ".subtask_create_input",
    },
    {
        trigger: ".o_kanban_record .o_widget_subtask_kanban_list .subtask_create_input input",
        content: 'Give the sub-task a name',
        run: "edit newer subtask && press Tab",
    },
    {
        content: "wait the new record is created",
        trigger: ".o_kanban_record .o_widget_subtask_kanban_list a:contains(newer subtask)",
    },
    {    
        trigger: ".o_kanban_record .o_widget_subtask_kanban_list .subtask_list_row:first-child .o_field_project_task_state_selection button",
        content: 'Change the subtask state',
        run: "click",
    },
    {
        trigger: ".dropdown-menu",
    },
    {
        trigger: ".dropdown-menu span.text-danger",
        content: 'Mark the task as Canceled',
        run: "click",
    }, {
        trigger: ".o_kanban_record .o_widget_subtask_counter .subtask_list_button:contains('1/2')",
        content: 'Close the sub-tasks list',
        id: "quick_create_tasks",
        run: "click",
    }, {
        trigger: '.o_field_text[name="name"] textarea',
        content: 'Set task name',
        run: "edit New task",
    }, {
        trigger: 'div[name="user_ids"].o_field_many2many_tags_avatar input',
        content: 'Assign the task to you',
        run: 'click',
    }, {
        trigger: 'ul.ui-autocomplete a .o_avatar_many2x_autocomplete',
        content: 'Assign the task to you',
        run: "click",
    }, {
        trigger: 'a[name="sub_tasks_page"]',
        content: 'Open sub-tasks notebook section',
        run: 'click',
    }, {
        trigger: '.o_field_subtasks_one2many .o_list_renderer a[role="button"]',
        content: 'Add a subtask',
        run: 'click',
    }, {
        trigger: '.o_field_subtasks_one2many div[name="name"] input',
        content: 'Set subtask name',
        run: "edit new subtask",
    },
    {
        trigger: '.o_field_many2many_tags_avatar .o_m2m_avatar',
    },
    {
        trigger: 'button[special="save"]',
        content: 'Save task',
        run: "click",
    },
]});

return __exports;
});
;

/***********************************************************************
*  Filepath: /project/static/tests/tours/project_update_tour_tests.js  *
*  Lines: 207                                                          *
***********************************************************************/
odoo.define('@project/../tests/tours/project_update_tour_tests', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add('project_update_tour', {
    url: '/odoo',
    steps: () => [stepUtils.showAppsMenuItem(), {
    trigger: '.o_app[data-menu-xmlid="project.menu_main_pm"]',
    run: "click",
},
{
    trigger: ".o_project_kanban",
},
{
    trigger: '.o-kanban-button-new',
    run: "click",
}, {
    trigger: '.o_project_name input',
    run: "edit New Project",
}, {
    trigger: '.o_open_tasks',
    run: "click .modal:visible .btn.btn-primary",
}, {
    trigger: ".o_kanban_project_tasks .o_column_quick_create .input-group input",
    run: "edit New",
}, {
    isActive: ["auto"],
    trigger: ".o_kanban_project_tasks .o_column_quick_create .o_kanban_add",
    run: "click",
},
{
    trigger: ".o_kanban_group",
},
{
    trigger: ".o_kanban_project_tasks .o_column_quick_create .input-group input",
    run: "edit Done",
}, {
    isActive: ["auto"],
    trigger: ".o_kanban_project_tasks .o_column_quick_create .o_kanban_add",
    run: "click",
},
{
    trigger: ".o_kanban_group:eq(0)",
},
{
    trigger: '.o-kanban-button-new',
    run: "click",
},
{
    trigger: ".o_kanban_project_tasks",
},
{
    trigger: '.o_kanban_quick_create div.o_field_char[name=display_name] input',
    run: "edit New task",
},
{
    trigger: ".o_kanban_project_tasks",
},
{
    trigger: '.o_kanban_quick_create .o_kanban_add',
    run: "click",
},
{
    trigger: ".o_kanban_group:eq(0)",
},
{
    trigger: '.o-kanban-button-new',
    run: "click",
},
{
    trigger: ".o_kanban_project_tasks",
},
{
    trigger: '.o_kanban_quick_create div.o_field_char[name=display_name] input',
    run: "edit Second task",
},
{
    trigger: ".o_kanban_project_tasks",
},
{
    trigger: '.o_kanban_quick_create .o_kanban_add',
    run: "click",
}, {
    trigger: ".o_kanban_group:nth-child(2) .o_kanban_header",
    run: "hover && click .o_kanban_group:nth-child(2) .o_kanban_header .dropdown-toggle",
}, {
    trigger: ".dropdown-item.o_column_edit",
    run: "click",
}, {
    trigger: ".modal .o_field_widget[name=fold] input",
    run: "click",
}, {
    trigger: ".modal .modal-footer button",
    run: "click",
},
{
    trigger: "body:not(:has(.modal))",
},
{
    trigger: '.o_kanban_project_tasks',
},
{
    trigger: ".o_kanban_record",
    run: "drag_and_drop(.o_kanban_group:eq(1))",
}, {
    trigger: ".o_control_panel_navigation button i.fa-sliders",
    content: 'Open embedded actions',
    run: "click",
}, {
    trigger: ".o_embedded_actions button i.fa-sliders",
    content: "Open embedded actions dropdown",
    run: "click",
}, {
    trigger: ".o-dropdown-item div span:contains('Dashboard')",
    content: "Put Dashboard in the embedded actions",
    run: "click",
}, {
    trigger: ".o_embedded_actions button span:contains('Dashboard')",
    content: "Open Dashboard",
    run: "click",
}, {
    trigger: ".o_add_milestone a",
    content: "Add a first milestone",
    run: "click",
}, {
    trigger: "div.o_field_widget[name=name] input",
    run: "edit New milestone",
}, {
    trigger: "input[data-field=deadline]",
    run: "edit 12/12/2099",
}, {
    trigger: ".modal-footer .o_form_button_save",
    run: "click",
},
{
    trigger: "body:not(:has(.modal))",
},
{
    trigger: ".o_add_milestone a",
    run: "click",
}, {
    trigger: "div.o_field_widget[name=name] input",
    run: "edit Second milestone",
}, {
    trigger: "input[data-field=deadline]",
    run: "edit 12/12/2022 && click body",
}, {
    trigger: ".modal-footer .o_form_button_save",
    run: "click",
},
{
    trigger: "body:not(:has(.modal))",
},
{
    trigger: ".o_rightpanel_milestone:eq(1) .o_milestone_detail",
    run: "click",
}, {
    trigger: "input[data-field=deadline]",
    run: "edit 12/12/2100 && click body",
}, {
    trigger: ".modal-footer .o_form_button_save",
    run: "click",
}, {
    trigger: ".o-kanban-button-new",
    content: "Create a new update",
    run: "click",
}, {
    trigger: "div.o_field_widget[name=name] input",
    run: "edit New update",
}, {
    trigger: ".o_form_button_save",
    run: "click",
}, {
    trigger: ".o_field_widget[name='description'] h1:contains('Activities')",
}, {
    trigger: ".o_field_widget[name='description'] h3:contains('Milestones')",
}, {
    trigger: ".o_field_widget[name='description'] div[name='milestone'] ul li:contains('(12/12/2099 => 12/12/2100)')",
}, {
    trigger: ".o_field_widget[name='description'] div[name='milestone'] ul li:contains('(due 12/12/2022)')",
}, {
    trigger: ".o_field_widget[name='description'] div[name='milestone'] ul li:contains('(due 12/12/2100)')",
}, {
    trigger: '.o_back_button',
    content: 'Go back to the kanban view the project',
    run: "click",
}, {
    trigger: '.o_switch_view.o_list',
    content: 'Open List View of Dashboard',
    run: "click",
},
{
    trigger: '.o_list_view',
},
{
    trigger: '.o_back_button',
    content: 'Go back to the kanban view the project',
    run: "click",
},
]});

return __exports;
});
;

/*********************************************************
*  Filepath: /hr/static/tests/tours/hr_employee_flow.js  *
*  Lines: 35                                             *
*********************************************************/
odoo.define('@hr/../tests/tours/hr_employee_flow', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add('hr_employee_tour', {
    url: '/odoo',
    steps: () => [
    stepUtils.showAppsMenuItem(),
    {
        content: "Open Employees app",
        trigger: ".o_app[data-menu-xmlid='hr.menu_hr_root']",
        run: 'click',
    },
    {
        content: "Open an Employee Profile",
        trigger: ".o_kanban_record:contains('Johnny H.')",
        run: 'click',
    },
    {
        content: "Open user account menu",
        trigger: ".o_user_menu .dropdown-toggle",
        run: 'click',
    }, {
        content: "Open My Profile",
        trigger: "[data-menu=settings]",
        run: 'click',
    },
]});

return __exports;
});
;

/*********************************************************************
*  Filepath: /hr/static/tests/tours/user_modify_own_profile_tour.js  *
*  Lines: 43                                                         *
*********************************************************************/
odoo.define('@hr/../tests/tours/user_modify_own_profile_tour', ['@web_tour/tour_service/tour_utils', '@web/core/registry', '@web/core/utils/patch'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { stepUtils } = require("@web_tour/tour_service/tour_utils");
const { registry } = require("@web/core/registry");
const { patch } = require("@web/core/utils/patch");

/**
 * As 'hr' changes the flow a bit and displays the user preferences form in a full view instead of
 * a modal, we adapt the steps of the original tour accordingly.
 */
patch(
    registry
        .category("web_tour.tours")
        .get("mail/static/tests/tours/user_modify_own_profile_tour.js"),
    {
        steps() {
            return [
                {
                    content: "Open user account menu",
                    trigger: ".o_user_menu button",
                    run: "click",
                },
                {
                    content: "Open preferences / profile screen",
                    trigger: "[data-menu=settings]",
                    run: "click",
                },
                {
                    content: "Update the email address",
                    trigger: 'div[name="email"] input',
                    run: "edit updatedemail@example.com",
                },
                ...stepUtils.saveForm(),
            ];
        },
    }
);

return __exports;
});
;

/********************************************************************************
*  Filepath: /hr_holidays/static/tests/tours/time_off_request_calendar_view.js  *
*  Lines: 58                                                                    *
********************************************************************************/
odoo.define('@hr_holidays/../tests/tours/time_off_request_calendar_view', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add("time_off_request_calendar_view", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            content: "Open Time Off app",
            trigger: '.o_app[data-menu-xmlid="hr_holidays.menu_hr_holidays_root"]',
            run: "click",
        },
        {
            content: "Click on the first Thursday of the year",
            trigger: ".fc-daygrid-day.fc-day-thu",
            run: () => {
                const el = document.querySelector(".fc-daygrid-day.fc-day-thu").firstChild;
                el.scrollIntoView();

                const fromPosition = el.getBoundingClientRect();
                fromPosition.x += el.offsetWidth / 2;
                fromPosition.y += el.offsetHeight / 2;

                el.dispatchEvent(
                    new MouseEvent("mousedown", {
                        bubbles: true,
                        which: 1,
                        button: 0,
                        clientX: fromPosition.x,
                        clientY: fromPosition.y,
                    })
                );
                el.dispatchEvent(
                    new MouseEvent("mouseup", {
                        bubbles: true,
                        which: 1,
                        button: 0,
                        clientX: fromPosition.x,
                        clientY: fromPosition.y,
                    })
                );
            },
        },
        {
            content: "Save the leave",
            trigger: '.btn:contains("Save")',
            run: "click",
        },
    ],
});

return __exports;
});
;

/********************************************************************************
*  Filepath: /project_todo/static/tests/tours/project_task_activities_split.js  *
*  Lines: 58                                                                    *
********************************************************************************/
odoo.define('@project_todo/../tests/tours/project_task_activities_split', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add('project_task_activities_split', {
    url: '/odoo',
    steps: () => [
        {
            content: 'Open Activity Systray',
            trigger: '.o-mail-ActivityMenu-counter',
            run: "click",
        }, {
            content: 'Open Task Activities',
            trigger: '.o-mail-ActivityGroup:contains("Task")',
            run: "click",
        }, {
            content: 'Task "New Task!" is listed in the activity view',
            trigger: '.o_activity_record .d-block:contains("New Task!")',
            run: "click",
        }, {
            content: 'Task "New Sub-Task!" is listed in the activity view',
            trigger: '.o_activity_record .d-block:contains("New Sub-Task!")',
            run: () => {
                const nodes = document.querySelectorAll(".o_activity_record .d-block");
                for (const node of nodes) {
                    if (node.textContent === "New To-do!") {
                        console.error('Private task records with no parent task should not appear in this view');
                    }
                }
            },
        }, {
            content: 'Open Activity Systray',
            trigger: '.o-mail-ActivityMenu-counter',
            run: "click",
        }, {
            content: 'Open To-Do Activities',
            trigger: '.o-mail-ActivityGroup:contains("To-Do")',
            run: "click",
        }, {
            content: 'Record "New To-Do!" is listed in the activity view',
            trigger: '.o_activity_record .d-block:contains("New To-Do!")',
            run: () => {
                const nodes = document.querySelectorAll(".o_activity_record .d-block");
                for (const node of nodes) {
                    if (node.textContent === "New Task!" || node.textContent === "New Sub-Task!") {
                        console.error('Tasks linked to a project should not appear in this view');
                    }
                }
            },
        }
    ],
});

return __exports;
});
;

/******************************************************************************
*  Filepath: /project_todo/static/tests/tours/project_todo_main_functions.js  *
*  Lines: 180                                                                 *
******************************************************************************/
odoo.define('@project_todo/../tests/tours/project_todo_main_functions', ['@odoo/owl', '@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { markup } = require("@odoo/owl");
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add('project_todo_main_functions', {
    url: '/odoo',
    steps: () => [stepUtils.showAppsMenuItem(), {
    trigger: '.o_app[data-menu-xmlid="project_todo.menu_todo_todos"]',
    run: "click",
}, {
    trigger: ".o_project_task_kanban_view .o_column_quick_create .o_kanban_add_column",
    content: "Create a personal stage from the To-do kanban view",
    run: "click",
},
{
    trigger: ".o_kanban_group",
},
{
    trigger: ".o_project_task_kanban_view .o_column_quick_create .o_kanban_header input",
    content: "Create a personal stage from the To-do kanban view",
    run: "edit Stage 1",
}, {
    trigger: ".o_project_task_kanban_view .o_column_quick_create .o_kanban_add",
    content: "Save the personal stage",
    run: "click",
},
{
    trigger: ".o_kanban_group",
},
{
    trigger: ".o_project_task_kanban_view .o_column_quick_create .o_kanban_header input",
    content: "Create a second personal stage from the To-do kanban view",
    run: "edit Stage 2",
}, {
    trigger: ".o_project_task_kanban_view .o_column_quick_create .o_kanban_add",
    content: "Save the personal stage",
    run: "click",
},
{
    trigger: ".o_kanban_group:eq(1)",
},
{
    trigger: '.o-kanban-button-new',
    content: "Create a task in the first stage",
    run: "click",
},
{
    trigger: ".o_project_task_kanban_view",
},
{
    trigger: '.o_kanban_quick_create div.o_field_char[name=name] input',
    content: "Create a personal task from the To-do kanban view",
    run: "edit Personal Task 1",
},
{
    trigger: ".o_project_task_kanban_view",
},
{
    trigger: '.o_kanban_quick_create .o_kanban_add',
    content: "Save the personal task",
    run: "click",
},
{
    trigger: ".o_project_task_kanban_view",
},
{
    trigger: ".o_kanban_record",
    content: "Drag &amp; drop the card to change the personal task from personal stage.",
    run: "drag_and_drop(.o_kanban_group:eq(1))",
},
{
    trigger: ".o_project_task_kanban_view",
},
{
    content: "Click on invisible caret. Should hover on card to be visible",
    trigger: ".o_dropdown_kanban .btn.o-no-caret:not(:visible)",
    run: "click",
}, {
    trigger: "a:contains('Set Cover Image')",
}, {
    trigger: ".o_kanban_record:first",//:contains(Send message)
    content: "Open the first todo record",
    run: "click",
},
{
    trigger: ".o_todo_form_view",
},
{
    trigger: ".todo_toggle_chatter",
    content: "Clicking on the chatter button should toggle open the chatter",
    run: "click",
},
{
    trigger: ".o-mail-Chatter-topbar button.o-mail-Chatter-sendMessage",
    content: "A 'send message' button should be present in the chatter",
    run: "click",
},
{
    trigger: ".o_todo_form_view",
},
{
    trigger: ".o-mail-Chatter-topbar button.o-mail-Chatter-logNote",
    content: "A 'log note' button should be present in the chatter",
    run: "click",
},
{
    trigger: ".o_todo_form_view",
},
{
    trigger: ".o-mail-Chatter-topbar button.o-mail-Chatter-activity",
    content: "An 'Activities' button should be present in the chatter",
    run: "click",
}, {
    trigger: "button[name=action_schedule_activities]",
    content: "Schedule an activity",
    run: "click",
},
{
    trigger: ".o_todo_form_view",
},
{
    trigger: ".o_field_widget[name='user_ids'] input",
    content: "Assign a responsible to your task",
    run: "fill marc",
},
{
    isActive: ["auto"],
    trigger: ".ui-autocomplete > li > a:not(:has(i.fa))",
    run: "click",
}, {
    trigger: '.o_field_widget[name="name"] textarea',
    content: 'Edit the name of the personal task',
    run: "edit New name for the personal task",
}, {
    trigger: '.o_todo_done_button',
    content: 'Mark the task as done',
    run: "click",
},
{
    trigger: ".o_todo_form_view .o_form_dirty",
},
{
    trigger: ".o_form_button_save",
    content: "Save the record",
    run: "click",
}, {
    trigger: '.o_breadcrumb .o_control_panel_breadcrumbs_actions button:enabled',
    content: "Convert the Todo to a task belonging to a project:enabled",
    run: "click",
}, {
    trigger: '.o_menu_item:contains("Convert to Task")',
    content: "Click on the action menu 'Convert to task'",
    run: "click",
}, {
    trigger: '.o_todo_conversion_form_view .o_field_many2one[name=project_id] input',
    content: 'Create a new project that will be set to the task',
    run: "edit Project test 1",
}, {
    trigger: '.o_todo_conversion_form_view .o_field_many2one[name=project_id] li.o_m2o_dropdown_option_create a',
    content: 'Create the new project',
    run: "click",
}, {
    trigger: 'button[name="action_convert_to_task"]',
    content: 'Convert the todo to a task',
    run: "click",
}, {
    trigger: ".breadcrumb-item:nth-child(1)",
    content: markup("Let's go back to the <b>kanban view</b> to have an overview of your next tasks."),
    run: "click",
}, {
    trigger: ".o_kanban_view",
}]});

return __exports;
});
;

/***********************************************************
*  Filepath: /hr_skills/static/tests/tours/skills_tour.js  *
*  Lines: 181                                              *
***********************************************************/
odoo.define('@hr_skills/../tests/tours/skills_tour', ['@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

registry.category("web_tour.tours").add("hr_skills_tour", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            content: "Open Employees app",
            trigger: ".o_app[data-menu-xmlid='hr.menu_hr_root']",
            run: "click",
        },
        {
            content: "Create a new employee",
            trigger: ".o-kanban-button-new",
            run: "click",
        },
        {
            content: "Pick a name",
            trigger: ".o_field_widget[name='name'] input",
            run: "edit Jony McHallyFace",
        },
        {
            content: "Save",
            trigger: ".o_form_button_save",
            run: "click",
        },
        {
            content: "Add a new Resume experience",
            trigger: ".o_field_resume_one2many tr.o_resume_group_header button.btn-secondary",
            run: "click",
        },
        {
            content: "Enter some company name",
            trigger:
                ".modal:contains(new resume line) .modal-body .o_field_widget[name='name'] input",
            run: "edit Mamie Rock",
        },
        {
            content: "Set start date",
            trigger: ".modal:contains(new resume line) .o_field_widget[name='date_start'] input",
            run: "edit 12/05/2017",
        },
        {
            content: "Give some description",
            trigger: ".modal:contains(new resume line) .o_field_html[name='description'] p",
            run: "editor Sang some songs and played some music",
        },
        {
            content: "Save it",
            trigger: ".modal:contains(new resume line) .o_form_button_save:contains(save)",
            run: "click",
        },
        {
            trigger: "body:not(:has(.modal:contains(new resume line)))",
        },
        {
            content: "Edit newly created experience",
            trigger: ".o_resume_line_title:contains(Mamie Rock)",
            run: "click",
        },
        {
            content: "Change type",
            trigger: ".modal:contains(new resume line) .o_field_widget[name='line_type_id'] input",
            run: "edit Experience",
        },
        {
            content: "Choose experience",
            trigger: '.ui-autocomplete .ui-menu-item a:contains("Experience")',
            run: "click",
        },
        {
            content: "Save experience change",
            trigger: ".modal:contains(new resume line) .o_form_button_save:contains(save)",
            run: "click",
        },
        {
            trigger: "body:not(:has(.modal:contains(new resume line)))",
        },
        {
            content: "Add a new Skill",
            trigger: ".o_field_skills_one2many button:contains('Pick a skill from the list')",
            run: "click",
        },
        {
            content: "Select Music",
            trigger:
                ".modal:contains(select skills) .o_field_widget[name='skill_type_id'] label:contains('Best Music')",
            run: "click",
        },
        {
            content: "Select a song",
            trigger: ".modal:contains(select skills) .o_field_widget[name='skill_id'] input",
            run: "edit Fortun",
        },
        {
            content: "Choose the song",
            trigger: '.ui-autocomplete .ui-menu-item a:contains("Fortunate Son")',
            run: "click",
        },
        {
            content: "Select a level",
            trigger: ".modal:contains(select skills) .o_field_widget[name='skill_level_id'] input",
            run: "edit Level",
        },
        {
            content: "Choose the level",
            trigger: '.ui-autocomplete .ui-menu-item a:contains("Level 2")',
            run: "click",
        },
        {
            content: "Save new skill",
            trigger: ".modal:contains(select skills) .o_form_button_save:contains(save & close)",
            run: "click",
        },
        {
            content:
                "Wait the new skill is completely saved. Ensure also the modal is closed before open a new one.",
            trigger: "body:not(:has(.modal))",
        },
        {
            content: "Check if item is added",
            trigger: ".o_data_row td.o_data_cell:contains('Fortunate Son')",
        },
        {
            content: "Add a new Skill",
            trigger: ".o_field_skills_one2many button:contains('ADD')",
            run: "click",
        },
        {
            content: "Music should be already selected",
            trigger:
                ".modal:contains(select skills) .o_field_widget[name=skill_id] input:value(Fortunate Son)",
        },
        {
            content: "Select a song",
            trigger: ".modal:contains(select skills) .o_field_widget[name='skill_id'] input",
            run: "edit Mary",
        },
        {
            content: "Choose the song",
            trigger: '.ui-autocomplete .ui-menu-item a:contains("Oh Mary")',
            run: "click",
        },
        {
            content: "Select a level",
            trigger: ".modal:contains(select skills) .o_field_widget[name='skill_level_id'] input",
            run: "edit Level 7",
        },
        {
            content: "Choose the level",
            trigger: '.ui-autocomplete .ui-menu-item a:contains("Level 7")',
            run: "click",
        },
        {
            content: "Save new skill",
            trigger: ".modal:contains(select skills) .o_form_button_save:contains(save & close)",
            run: "click",
        },
        {
            content: "Wait the new skill is completely saved",
            trigger: "body:not(:has(.modal))",
        },
        {
            content: "Check if item is added",
            trigger: ".o_data_row td.o_data_cell:contains('Oh Mary')",
        },
        {
            content: "wait for save completion",
            trigger: ".o_form_readonly, .o_form_saved",
        },
    ],
});

return __exports;
});
;

/***************************************************
*  Filepath: /auth_totp/static/tests/totp_flow.js  *
*  Lines: 371                                      *
***************************************************/
odoo.define('@auth_totp/../tests/totp_flow', ['@odoo/hoot-dom', '@web/core/network/rpc', '@web/core/registry', '@web_tour/tour_service/tour_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { queryAll } = require("@odoo/hoot-dom");
const { rpc } = require("@web/core/network/rpc");
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");

function openRoot() {
    return [{
        content: "return to client root to avoid race condition",
        trigger: 'body',
        run() {
            document.querySelector("body").classList.add("wait");
            window.location = '/odoo';
        }
    }, {
        content: "wait for client reload",
        trigger: 'body:not(.wait)',
    }];
}
function openUserProfileAtSecurityTab() {
    return [{
        content: 'Open user account menu',
        trigger: '.o_user_menu .dropdown-toggle',
        run: 'click',
    }, {
        content: "Open preferences / profile screen",
        trigger: '[data-menu=settings]',
        run: 'click',
    }, {
        content: "Switch to security tab",
        trigger: 'a[role=tab]:contains("Account Security")',
        run: 'click',
    }];
}

/**
 * Checks that the TOTP button is in the specified state (true = enabled =
 * can disable, false = disabled = can enable), then closes the profile dialog
 * if it's one (= hr not installed).
 *
 * If no totp state is provided, just checks that the toggle exists.
 */
function closeProfileDialog({content, totp_state}) {
    let trigger;
    switch (totp_state) {
    case true: trigger = 'button[name=action_totp_disable]'; break;
    case false: trigger = 'button[name=action_totp_enable_wizard]'; break;
    case undefined: trigger = 'button.o_auth_2fa_btn'; break;
    default: throw new Error(`Invalid totp state ${totp_state}`)
    }

    return [{
        content,
        trigger,
        run(helpers) {
            const modal = document.querySelector(".o_dialog");
            if (modal) {
                modal.querySelector("button[name=preference_cancel]").click();
            }
        }
    }, {
        trigger: 'body',
        async run() {
            while (document.querySelector('.o_dialog')) {
                await Promise.resolve();
            }
            this.anchor.classList.add("dialog-closed");
        },
    }, {
        trigger: 'body.dialog-closed',
    }];
}

registry.category("web_tour.tours").add('totp_tour_setup', {
    url: '/odoo',
    steps: () => [...openUserProfileAtSecurityTab(), {
    content: "Open totp wizard",
    trigger: 'button[name=action_totp_enable_wizard]',
    run: "click",
},
{
    trigger: ".modal div:contains(entering your password)",
},
{
    content: "Check that we have to enter enhanced security mode and input password",
    trigger: '[name=password] input',
    run: 'edit test_user',
}, {
    content: "Confirm",
    trigger: "button:contains(Confirm Password)",
    run: "click",
}, {
    content: "Check the wizard has opened",
    trigger: '.modal li:contains("When requested to do so")',
}, {
    content: "Get secret from collapsed div",
    trigger: `.modal a:contains("Cannot scan it?")`,
    async run(helpers) {
        const secret = this.anchor
            .closest("div")
            .querySelector("[name=secret] span:first-child");
        const copyBtn = secret.querySelector("button");
        if (copyBtn) {
            copyBtn.remove();
        }
        const token = await rpc('/totphook', {
            secret: secret.textContent
        });
        await helpers.edit(token, '[name=code] input');
        document.querySelector("body").classList.add("got-token");
    }
},
{
    trigger: ".modal button.btn-primary:contains(Activate)",
    run: "click",
},
{
    trigger: "body:not(:has(.modal))",
},
{
    content: 'wait for rpc',
    trigger: 'body.got-token',
},
...openRoot(),
...openUserProfileAtSecurityTab(),
...closeProfileDialog({
    content: "Check that the button has changed",
    totp_state: true,
}),
]});

registry.category("web_tour.tours").add('totp_login_enabled', {
    url: '/',
    steps: () => [{
    content: "check that we're on the login page or go to it",
    trigger: 'input#login, a:contains(Sign in)',
    run: "click",
}, {
    content: "input login",
    trigger: 'input#login',
    run: "edit test_user",
}, {
    content: 'input password',
    trigger: 'input#password',
    run: "edit test_user",
}, {
    content: "click da button",
    trigger: 'button:contains("Log in")',
    run: "click",
}, {
    content: "expect totp screen",
    trigger: 'label:contains(Authentication Code)',
    run: "click",
}, {
    content: "input code",
    trigger: 'input[name=totp_token]',
    async run(helpers) {
        const token = await rpc('/totphook');
        helpers.edit(token);
    }
},
{
    trigger: `button:contains("Log in")`,
    run: "click",
},
{
    content: "check we're logged in",
    trigger: ".o_user_menu .dropdown-toggle",
}]});

registry.category("web_tour.tours").add('totp_login_device', {
    url: '/',
    steps: () => [{
    content: "check that we're on the login page or go to it",
    trigger: 'input#login, a:contains(Sign in)',
    run: "click",
}, {
    content: "input login",
    trigger: 'input#login',
    run: "edit test_user",
}, {
    content: 'input password',
    trigger: 'input#password',
    run: "edit test_user",
}, {
    content: "click da button",
    trigger: 'button:contains("Log in")',
    run: "click",
}, {
    content: "expect totp screen",
    trigger: 'label:contains(Authentication Code)',
    run: "click",
}, {
    content: "check remember device box",
    trigger: 'label[for=switch-remember]',
    run: "click",
}, {
    content: "input code",
    trigger: 'input[name=totp_token]',
    async run(helpers) {
        const token = await rpc('/totphook')
        helpers.edit(token);
    }
},
{
    trigger: "button:contains(Log in)",
    run: "click",
},
{
    content: "check we're logged in",
    trigger: ".o_user_menu .dropdown-toggle",
    run: 'click',
}, {
    content: "click the Log out button",
    trigger: '.dropdown-item[data-menu=logout]',
    run: "click",
}, {
    content: "check that we're back on the login page or go to it",
    trigger: 'input#login, a:contains(Log in)',
    run: "edit Test",
}, {
    content: "input login again",
    trigger: 'input#login',
    run: "edit test_user",
}, {
    content: 'input password again',
    trigger: 'input#password',
    run: "edit test_user",
}, {
    content: "click da button again",
    trigger: 'button:contains("Log in")',
    run: "click",
},  {
    content: "check we're logged in without 2FA",
    trigger: ".o_user_menu .dropdown-toggle",
},
// now go and disable two-factor authentication would be annoying to do in a separate tour
// because we'd need to login & totp again as HttpCase.authenticate can't
// succeed w/ totp enabled
...openUserProfileAtSecurityTab(),
{
    content: "Open totp wizard",
    trigger: 'button[name=action_totp_disable]',
    run: "click",
},
{
    trigger: ".modal div:contains(entering your password)",
},
{
    content: "Check that we have to enter enhanced security mode and input password",
    trigger: '.modal [name=password] input',
    run: "edit test_user",
}, {
    content: "Confirm",
    trigger: ".modal button:contains(Confirm Password)",
    run: "click",
},
{
    trigger: "body:not(:has(.modal))",
},
...openRoot(),
...openUserProfileAtSecurityTab(),
...closeProfileDialog({
    content: "Check that the button has changed",
    totp_state: false
}),
]});

registry.category("web_tour.tours").add('totp_login_disabled', {
    url: '/',
    steps: () => [{
    content: "check that we're on the login page or go to it",
    trigger: 'input#login, a:contains(Sign in)',
    run: "click",
}, {
    content: "input login",
    trigger: 'input#login',
    run: "edit test_user",
}, {
    content: 'input password',
    trigger: 'input#password',
    run: "edit test_user",
}, {
    content: "click da button",
    trigger: 'button:contains("Log in")',
    run: "click",
},
// normally we'd end the tour here as it's all we care about but there are a
// bunch of ongoing queries from the loading of the web client which cause
// issues, so go and open the preferences / profile screen to make sure
// everything settles down
...openUserProfileAtSecurityTab(),
// close the dialog if that makes sense
...closeProfileDialog({})
]});

const columns = {};
registry.category("web_tour.tours").add('totp_admin_disables', {
    url: '/odoo',
    steps: () => [stepUtils.showAppsMenuItem(), {
    content: 'Go to settings',
    trigger: '[data-menu-xmlid="base.menu_administration"]',
    run: "click",
}, {
    content: 'Wait for page',
    trigger: '.o_menu_brand:contains("Settings")',
}, {
    content: "Open Users menu",
    trigger: '[data-menu-xmlid="base.menu_users"]',
    run: "click",
}, {
    content: "Open Users view",
    trigger: '[data-menu-xmlid="base.menu_action_res_users"]',
    run: "click",
}, {
    content: "Find test_user User",
    trigger: 'td.o_data_cell:contains("test_user")',
    run(helpers) {
        const titles = queryAll("tr:first th", { root: this.anchor.closest("table") });
        titles.forEach((el, i) => {
            columns[el.getAttribute('data-name')] = i;
        })
        const row = this.anchor.closest('tr');
        const sel = row.querySelector('.o_list_record_selector input[type=checkbox]');
        helpers.click(sel);
    }
}, {
    content: "Open Actions menu",
    trigger: 'button.dropdown-toggle:contains("Action")',
    run: "click",
}, {
    content: "Select totp remover",
    trigger: 'span.dropdown-item:contains(Disable two-factor authentication)',
    run: "click",
},
{
    trigger: ".modal div:contains(entering your password)",
},
{ // enhanced security yo
    content: "Check that we have to enter enhanced security mode & input password",
    trigger: '.modal [name=password] input',
    run: "edit admin",
}, {
    content: "Confirm",
    trigger: ".modal button:contains(Confirm Password)",
    run: "click",
},
{
    content: "Wait the modal is closed",
    trigger: "body:not(:has(.modal))",
},
{
    content: "open the user's form",
    trigger: "td.o_data_cell:contains(test_user)",
    run: "click",
}, {
    content: "go to Account security Tab",
    trigger: "a.nav-link:contains(Account Security)",
    run: "click",
}, ...closeProfileDialog({
    content: "check that test_user user has been de-totp'd",
    totp_state: false,
}),
]})

return __exports;
});
;

/********************************************************
*  Filepath: /auth_totp_mail/static/tests/totp_flow.js  *
*  Lines: 84                                            *
********************************************************/
odoo.define('@auth_totp_mail/../tests/totp_flow', ['@web/core/registry', '@web_tour/tour_service/tour_utils', '@odoo/hoot-dom'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_service/tour_utils");
const { queryFirst } = require("@odoo/hoot-dom");

function openAccountSettingsTab() {
    return [{
        content: 'Go to settings',
        trigger: '[data-menu-xmlid="base.menu_administration"]',
        run: "click",
    }, {
        content: 'Wait for page',
        trigger: '.o_menu_brand:contains("Settings")',
    }, {
        content: "Open Users menu",
        trigger: '[data-menu-xmlid="base.menu_users"]',
        run: "click",
    }, {
        content: "Open Users view",
        trigger: '[data-menu-xmlid="base.menu_action_res_users"]',
        run: function (helpers) {
            // funny story: the users view we're trying to reach, sometimes we're
            // already there, but if we re-click the next step executes before the
            // action has the time to re-load, the one after that doesn't, and our
            // selection get discarded by the action reloading, so here try to
            // see if we're already on the users action through the breadcrumb and
            // just close the menu if so
            const breadcrumb = document.querySelector('.breadcrumb');
            if (!breadcrumb || !breadcrumb.textContent.includes("Users")) {
                // on general settings page, click menu
                helpers.click();
            } else {
                // else close menu
                helpers.click('[data-menu-xmlid="base.menu_users"]');
            }
        }
    }];
}

registry.category("web_tour.tours").add('totp_admin_self_invite', {
    url: '/odoo',
    steps: () => [stepUtils.showAppsMenuItem(), ...openAccountSettingsTab(), {
    content: "open the user's form",
    trigger: "td.o_data_cell:contains(admin)",
    run: "click",
}, {
    content: "go to Account security Tab",
    trigger: "a.nav-link:contains(Account Security)",
    run: "click",
}, {
    content: "check that user cannot invite themselves to use 2FA.",
    trigger: "body",
    run: function () {
        const inviteBtn = queryFirst('button:contains(Invite to use 2FA)');
        if (!inviteBtn) {
            document.body.classList.add('CannotInviteYourself');
        }
    }
}, {
    content: "check that user cannot invite themself.",
    trigger: "body.CannotInviteYourself",
}]});

registry.category("web_tour.tours").add('totp_admin_invite', {
    url: '/odoo',
    steps: () => [stepUtils.showAppsMenuItem(), ...openAccountSettingsTab(), {
    content: "open the user's form",
    trigger: "td.o_data_cell:contains(test_user)",
    run: "click",
}, {
    content: "go to Account security Tab",
    trigger: "a.nav-link:contains(Account Security)",
    run: "click",
}, {
    content: "check that test_user user can be invited to use 2FA.",
    trigger: "button:contains(Invite to use 2FA)",
}]});

return __exports;
});
;

/************************************************************
*  Filepath: /auth_totp_portal/static/tests/totp_portal.js  *
*  Lines: 130                                               *
************************************************************/
odoo.define('@auth_totp_portal/../tests/totp_portal', ['@web/core/registry', '@web/core/network/rpc'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { rpc } = require("@web/core/network/rpc");

registry.category("web_tour.tours").add('totportal_tour_setup', {
    url: '/my/security',
    steps: () => [{
    content: "Open totp wizard",
    trigger: 'button#auth_totp_portal_enable',
    run: "click",
}, {
    content: "Check that we have to enter enhanced security mode",
    trigger: ".modal div:contains(enter your password)",
}, {
    content: "Input password",
    trigger: '[name=password]',
    run: "edit portal", // FIXME: better way to do this?
}, {
    content: "Confirm",
    trigger: "button:contains(Confirm Password)",
    run: "click",
}, {
    content: "Check the wizard has opened",
    trigger: 'li:contains("scan the barcode below")',
}, {
    content: "Get secret from collapsed div",
    trigger: 'a:contains("Cannot scan it?")',
    run: async function(helpers) {
        const secret = this.anchor
            .closest("div")
            .querySelector('span[name="secret"]').textContent;
        const token = await rpc('/totphook', {
            secret
        });
        await helpers.edit(token, 'input[name="code"]');
        await helpers.click("button.btn-primary:contains(Activate)");
    }
}, {
    content: "Check that the button has changed",
    trigger: 'button:contains(Disable two-factor authentication)',
}]});

registry.category("web_tour.tours").add('totportal_login_enabled', {
    url: '/',
    steps: () => [{
    content: "check that we're on the login page or go to it",
    trigger: 'input#login, a:contains(Sign in)',
    run: "click",
}, {
    content: "input login",
    trigger: 'input#login',
    run: "edit portal",
}, {
    content: 'input password',
    trigger: 'input#password',
    run: "edit portal",
}, {
    content: "click da button",
    trigger: 'button:contains("Log in")',
    run: "click",
}, {
    content: "expect totp screen",
    trigger: 'label:contains(Authentication Code)',
    run: "click",
}, {
    content: "input code",
    trigger: 'input[name=totp_token]',
    run: async function (helpers) {
        const token = await rpc('/totphook');
        await helpers.edit(token);
        // FIXME: is there a way to put the button as its own step trigger without
        //        the tour straight blowing through and not waiting for this?
        await helpers.click('button:contains("Log in")');
    }
}, {
    content: "check we're logged in",
    trigger: "h3:contains(My account)",
}, {
    content: "go back to security",
    trigger: "a:contains(Security)",
    run: "click",
},{
    content: "Open totp wizard",
    trigger: 'button#auth_totp_portal_disable',
    run: "click",
}, {
    content: "Check that we have to enter enhanced security mode",
    trigger: ".modal div:contains(enter your password)",
}, {
    content: "Input password",
    trigger: '[name=password]',
    run: "edit portal", // FIXME: better way to do this?
}, {
    content: "Confirm",
    trigger: "button:contains(Confirm Password)",
    run: "click",
}, {
    content: "Check that the button has changed",
    trigger: 'button:contains(Enable two-factor authentication)',
}]});

registry.category("web_tour.tours").add('totportal_login_disabled', {
    url: '/',
    steps: () => [{
    content: "check that we're on the login page or go to it",
    trigger: 'input#login, a:contains(Sign in)',
    run: "click",
}, {
    content: "input login",
    trigger: 'input#login',
    run: "edit portal",
}, {
    content: 'input password',
    trigger: 'input#password',
    run: "edit portal",
}, {
    content: "click da button",
    trigger: 'button:contains("Log in")',
    run: "click",
}, {
    content: "check we're logged in",
    trigger: "h3:contains(My account)",
}]});

return __exports;
});


//# sourceMappingURL=/web/assets/5fc78cb/web.assets_tests.js.map